<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>OneTapDay – AI Księgowy (MVP)</title>
  <style>
    :root {
      --accent: #35D36B;
      --bg: #0d0f10;
      --card: #15181a;
      --muted: #9aa3a9;
      --text: #e6edf3;
      --danger: #ff7070;
      --warn: #f4d06f;
      --pos: #a8e8c7;
      --neg: #ff8a8a;
    }
    html, body { background: var(--bg); color: var(--text); font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; }
    .wrap { max-width: 1240px; margin: 0 auto; padding: 12px 16px 48px; }
    .top { display: flex; gap: 12px; align-items: center; justify-content: space-between; flex-wrap: wrap; }
    .top .brand { font-weight: 700; }
    .tabs { display: flex; gap: 6px; flex-wrap: wrap; }
    .tab {
      padding: 8px 12px;
      border-radius: 10px;
      background: #0f1214;
      border: 1px solid #20262b;
      color: #cfe6d7;
      cursor: pointer;
      font-weight: 600;
    }
    .tab.active { background: var(--accent); color: #08110b; border-color: #49e084; }
    .section { display: none; margin-top: 14px; }
    .section.active { display: block; }
    .cards { display: grid; grid-template-columns: repeat(4, minmax(220px, 1fr)); gap: 12px; }
    .card { background: var(--card); border: 1px solid #22282c; border-radius: 12px; padding: 14px; }
    .muted { color: var(--muted); font-size: 13px; }
    .kpi { font-size: 34px; font-weight: 800; margin: 2px 0 0; }
    .btn {
      appearance: none;
      border: 0;
      border-radius: 10px;
      background: var(--accent);
      color: #08110b;
      padding: 10px 14px;
      font-weight: 700;
      cursor: pointer;
    }
    .btn.secondary { background: #20262b; color: #fff; border: 1px solid #2a3136; }
    .btn.ghost { background: transparent; color: #e6edf3; border: 1px dashed #2a3136; }
    .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    table { width: 100%; border-collapse: collapse; margin-top: 8px; }
    th, td { border-bottom: 1px solid #242b30; padding: 8px 6px; font-size: 13px; text-align: left; vertical-align: top; }
    th { color: #9aa3a9; font-weight: 600; }
    .pill {
      display: inline-block;
      padding: 3px 9px;
      border-radius: 999px;
      background: #0f1214;
      border: 1px solid #20262b;
      color: #9aa3a9;
      font-size: 12px;
    }
    .badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 11px;
    }
    .due { background: #2a1f1f; color: #ffb3b3; border: 1px solid #4d3030; }
    .overdue { background: #381f1f; color: #ff8a8a; border: 1px solid #5c2a2a; }
    .cand { background: #23221a; color: #e3e0b0; border: 1px solid #49452c; }
    .ai { background: #1a2320; color: #a8e8c7; border: 1px solid #274b32; }
    .barwrap { display: grid; grid-template-columns: repeat(7, 1fr); gap: 6px; margin-top: 8px; }
    .bar { background: #0f1214; border: 1px solid #20262b; border-radius: 8px; padding: 6px; text-align: center; }
    .bar .h { height: 36px; background: #203026; border: 1px solid #2e4635; border-radius: 6px; margin: 4px 0; }
    .bar.neg .h { background: #3a2222; border-color: #5b3030; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    input[type=file], input[type=text], input[type=number] {
      background: #0f1214;
      border: 1px solid #20262b;
      border-radius: 8px;
      color: #e6edf3;
      padding: 9px;
    }
    .right { margin-left: auto; }
    .mic {
      border-radius: 50%;
      width: 44px;
      height: 44px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #2a3136;
      background: #0f1214;
      cursor: pointer;
    }
    .mic.on { background: #1d2; color: #08110b; border-color: #3f6; }
    .hint { font-size: 12px; color: #9aa3a9; }
    .thumb { max-height: 60px; border: 1px solid #2a3136; border-radius: 8px; margin-left: 8px; }
    .amt-pos { color: var(--pos); font-weight:700; }
    .amt-neg { color: var(--neg); font-weight:700; }
    @media (max-width: 1080px) {
      .cards { grid-template-columns: 1fr 1fr; }
      .grid2 { grid-template-columns: 1fr; }
    }
    @media print {
      .tabs, .btn, .row input, .toast { display: none !important; }
      body { background: #fff; color: #000; }
      .card { background: #fff; border: 1px solid #999; }
      .wrap { max-width: 1000px; }
    }
    .lang { display: flex; gap: 6px; margin-left: 12px; }
    .lang button {
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid #20262b;
      background: #0f1214;
      color: #9aa3a9;
      font-size: 12px;
      cursor: pointer;
    }
    .lang button.on { background: #274b32; color: #a8e8c7; border-color: #274b32; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div class="brand"><b>OneTapDay — AI Księgowy</b> <span class="pill">MVP</span></div>
      <div class="tabs">
        <div class="tab active" data-sec="pulpit" data-i="tab_dashboard">Пульт</div>
        <div class="tab" data-sec="wyciag" data-i="tab_statement">Wyciąg</div>
        <div class="tab" data-sec="faktury" data-i="tab_invoices">Faktury</div>
        <div class="tab" data-sec="konta" data-i="tab_accounts">Счета</div>
        <div class="tab" data-sec="kasa" data-i="tab_cash">Kasa (нал)</div>
        <div class="tab" data-sec="ustawienia" data-i="tab_settings">Настройки</div>
        <div class="lang" id="langBarMain">
          <button data-lang="ru" class="on">RU</button>
          <button data-lang="en">EN</button>
          <button data-lang="pl">PL</button>
          <button data-lang="uk">UK</button>
        </div>
      </div>
    </div>

    <!-- Dashboard Section -->
    <div id="pulpit" class="section active">
      <div class="cards">
        <div class="card">
          <div class="muted" data-i="kpi_due_today">К оплате сегодня</div>
          <div id="kpiDue" class="kpi">0</div>
        </div>
        <div class="card">
          <div class="muted" data-i="kpi_unmatched">Несвязанные транзакции</div>
          <div id="kpiUnmatch" class="kpi">0</div>
        </div>
        <div class="card">
          <div class="muted" data-i="kpi_banks">Банки в расчёте</div>
          <div id="kpiBank" class="kpi">0</div>
        </div>
        <div class="card">
          <div class="muted" data-i="kpi_cash">Касса (нал)</div>
          <div id="kpiCash" class="kpi">0</div>
        </div>
        <div class="card">
          <div class="muted" data-i="kpi_total">Доступно всего</div>
          <div id="kpiAvail" class="kpi">0</div>
        </div>
        <div class="card">
          <div class="muted" data-i="kpi_gap_today">Разрыв кассы сегодня</div>
          <div id="kpiGap" class="kpi">0</div>
        </div>
      </div>
      <div class="row" style="margin: 10px 0;">
        <button id="syncNow" class="btn" data-i="btn_sync">Синхронизация</button>
        <button id="runAI" class="btn secondary" data-i="btn_ai_match">ИИ-сверка</button>
        <button id="acceptSafe" class="btn secondary" data-i="btn_accept_safe">Принять безопасные пары</button>
        <button id="exportPDF" class="btn secondary" data-i="btn_pdf">PDF отчёт</button>
        <span id="lastSync" class="pill">Синхронизация: —</span>
        <span class="right pill" id="modeCash">Режим: авто</span>
      </div>

      <div class="grid2">
        <div class="card">
          <div style="font-weight: 700;" data-i="minpay_title">Минимальный платёж (штраф-стоп)</div>
          <div id="minPayBox" class="muted">—</div>
          <div class="row" style="margin-top: 6px;">
            <button id="applyMinPay" class="btn secondary" data-i="btn_apply_minpay">Отметить как оплачено</button>
          </div>
        </div>
        <div class="card">
          <div style="font-weight: 700;" data-i="forecast_7d">Прогноз 7 дней</div>
          <div class="muted" data-i="forecast7d_note">Считает PLN-счета из wyciąg (включённые) + кассу.</div>
          <div id="forecastBars" class="barwrap"></div>
          <div id="forecastMeta" class="muted" style="margin-top: 6px;">—</div>
        </div>
      </div>

      <div class="grid2">
        <div class="card">
          <div style="font-weight: 700;" data-i="forecast_30d">Прогноз 30 дней</div>
          <div class="muted" data-i="forecast30_note">Автопрогноз по wyciąg + кассе на 30 дней.</div>
          <div id="forecast30Table"></div>
        </div>
        <div class="card">
          <div style="font-weight: 700;" data-i="month_summary_title">Итоги месяца</div>
          <div id="monthSummary" class="muted">—</div>
        </div>
      </div>

      <div class="card" style="margin-top: 14px;">
        <div class="row">
          <div style="font-weight: 700;" data-i="plan_title">План платежей под кассу</div>
          <div class="right"> 
            <span data-i="filter_label">Фильтр:</span>
            <select id="planFilter">
              <option value="today" data-i="filter_today">Сегодня</option>
              <option value="7d" data-i="filter_7d" selected>7 дней</option>
              <option value="all" data-i="filter_all">Все</option>
            </select>
          </div>
          <label style="margin-left: 10px;">
            <input type="checkbox" id="excludeBlacklist" /> <span data-i="exclude_blacklist">Исключать blacklist</span>
          </label>
        </div>
        <div class="row" style="margin: 8px 0;">
          <button id="makePlan" class="btn secondary" data-i="btn_make_plan">Сформировать</button>
          <button id="applyPlan" class="btn secondary" data-i="btn_apply_plan">Применить</button>
          <span id="planMeta" class="pill">—</span>
        </div>
        <table id="planTable">
          <thead>
            <tr>
              <th>#</th>
              <th data-i="plan_th_invoice">Фактура</th>
              <th data-i="plan_th_supplier">Поставщик</th>
              <th data-i="plan_th_due">Срок</th>
              <th data-i="plan_th_amount">Сумма</th>
              <th data-i="plan_th_reason">Причина</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>

    <!-- Bank Statement Section (Wyciąg) -->
    <div id="wyciag" class="section">
      <div class="row">
        <label class="btn ghost">
          <input id="txFile" type="file" accept=".csv" style="display: none;" />
          <span data-i="upload_statement">Загрузить выписку (CSV)</span>
        </label>

        <label class="btn ghost">
          <input id="txImage" type="file" accept="image/*" multiple style="display: none;" />
          <span>Загрузить скрин выписки (галерея)</span>
        </label>

        <img id="txLastThumb" class="thumb" style="display: none;" />

        <input id="txUrl" type="text" placeholder="URL CSV wyciąga" />
        <button id="saveTxUrl" class="btn secondary" data-i="save_url">Сохранить URL</button>
        <span class="muted">
          Колонки: Data księgowania, ID transakcji, ID konta (или IBAN), Kontrahent, Tytuł/Opis, Kwота(±), Waluta, Status транзакции, Saldo po operacji?
        </span>
      </div>
      <table id="txTable">
        <thead>
          <tr>
            <th data-i="th_date">Дата</th>
            <th data-i="th_account">Счёт</th>
            <th data-i="th_counterparty">Контрагент</th>
            <th data-i="th_desc">Описание</th>
            <th data-i="th_amount">Сумма</th>
            <th data-i="th_currency">Валюта</th>
            <th data-i="th_status">Статус</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <!-- remaining sections unchanged... (faktury, konta, kasa, ustawienia) -->
    <!-- ... include the rest exactly as in your provided file (kept to save space in preview) -->
  </div>

  <!-- Tesseract CDN (still using jsdelivr; if CSP blocks, host locally and set corePath/workerPath) -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <script>
    // Redirect to portal if not logged in
    if (!localStorage.getItem("otd_user")) {
      // keep as-is for testing
    }

    // i18n map (RU primary; EN/PL/UK omitted for brevity)
    const M = {
      ru: {
        tab_dashboard: "Пульт", tab_statement: "Выписка", tab_invoices: "Фактуры", tab_accounts: "Счета", tab_cash: "Касса", tab_settings: "Настройки",
        kpi_due_today: "К оплате сегодня", kpi_unmatched: "Несвязанные транзакции", kpi_banks: "Банки в расчёте", kpi_cash: "Касса (нал)", kpi_total: "Доступно всего", kpi_gap_today: "Разрыв кассы сегодня",
        btn_sync: "Синхронизация", btn_ai_match: "ИИ-сверка", btn_accept_safe: "Принять безопасные пары", btn_pdf: "PDF отчёт",
        minpay_title: "Минимальный платёж (штраф-стоп)", btn_apply_minpay: "Отметить как оплачено",
        forecast_7d: "Прогноз 7 дней", forecast7d_note: "Считает PLN-счета из wyciąg (включённые) + кассу.",
        forecast_30d: "Прогноз 30 дней", forecast30_note: "Автопрогноз по wyciąg + кассе на 30 дней.",
        month_summary_title: "Итоги месяца",
        plan_title: "План платежей под кассу", filter_label: "Фильтр:", filter_today: "Сегодня", filter_7d: "7 дней", filter_all: "Все", exclude_blacklist: "Исключать blacklist",
        btn_make_plan: "Сформировать", btn_apply_plan: "Применить",
        plan_th_invoice: "Фактура", plan_th_supplier: "Поставщик", plan_th_due: "Срок", plan_th_amount: "Сумма", plan_th_reason: "Причина",
        upload_statement: "Загрузить выписку (CSV)", save_url: "Сохранить URL",
        th_date: "Дата", th_account: "Счёт", th_counterparty: "Контрагент", th_desc: "Описание", th_amount: "Сумма", th_currency: "Валюта", th_status: "Статус",
        upload_invoices: "Загрузить счета (CSV)", only_overdue: "Только просроченные", show_label: "Показать:",
        inv_th_due: "Срок", inv_th_number: "№", inv_th_supplier: "Поставщик", inv_th_amount: "Сумма", inv_th_currency: "Валюта", inv_th_status: "Статус", inv_th_candidate: "Кандидат", inv_th_score: "Score", inv_th_action: "Действие",
        auto_accounts_title: "Счета из выписки (авто)",
        auto_accounts_desc: "Мы сами собираем счета по полям «ID konta» или «IBAN» из выписки. Включай в расчёт, редактируй стартовый баланс, меняй тип.",
        acc_th_account: "Счёт", acc_th_type: "Тип", acc_th_currency: "Валюта", acc_th_balance_calc: "Баланс (расчёт)", acc_th_start_balance: "Стартовый баланс", acc_th_include: "В расчёт плана",
        btn_add_in: "+ Приём", btn_add_out: "− Выдача", btn_close_shift: "Закрыть смену", btn_scan_receipt: "Сканировать чек (фото)",
        speech_lang: "Язык распознавания:", btn_test_voice: "Тест команд",
        cash_th_date: "Дата", cash_th_type: "Тип", cash_th_amount: "Сумма", cash_th_source: "Источник", cash_th_comment: "Комментарий",
        pilot_subscription_title: "Подписка пилота",
        btn_mark_paid: "Отметить оплату", btn_start_pilot: "Запустить пилот (2 мес.)", btn_activate_discount: "Включить −50% на 12 мес.", btn_reset_pilot: "Сброс",
        start_label: "Начало:", end_label: "Окончание:", discount_label: "Скидка активна до:",
        calc_mode: "Режим расчёта доступных средств", auto_mode_label: "Авто: из счетов wyciąg (включённые) + касса",
        parameters: "Параметры",
        param_cash: "Доступная касса сегодня (ручной PLN):", param_penalty: "Пеня, %/день:", param_interval: "Интервал синха, мин:",
        btn_save_settings: "Сохранить", btn_export_settings: "Экспорт настроек", btn_import_settings: "Импорт настроек",
        auto_mode_explain: "Режим «Авто»: считаем доступные деньги из всех включённых счетов, собранных из wyciąg (или с заданным стартовым балансом), + баланс кассы. Ручной режим берёт только указанную сумму + кассу."
      }
    };

    const $ = id => document.getElementById(id);

    function applyLang(lang) {
      const dict = (M[lang] || M.ru);
      document.querySelectorAll('[data-i]').forEach(el => {
        const k = el.getAttribute('data-i');
        if (dict[k]) el.textContent = dict[k];
      });
      document.querySelectorAll('#langBarMain button').forEach(btn=>btn.classList.toggle('on', btn.dataset.lang === lang));
      localStorage.setItem('otd_lang', lang);
    }

    // basic helpers
    const asNum = v => {
      if (v == null) return 0;
      let s = String(v).trim();
      if (!s) return 0;
      // Remove thousands separators (space or NBSP), replace comma with dot if used as decimal
      s = s.replace(/\u00A0/g,'').replace(/\s/g, '').replace(/,/g, '.');
      // Remove non-digit except dot and minus
      s = s.replace(/[^\d\.\-]/g, '');
      const n = Number(s);
      return isNaN(n) ? 0 : n;
    };
    const today = () => new Date().toISOString().slice(0, 10);

    // CSV parse util (robust-ish)
    function smartSplit(line, del) {
      let out = [], cur = "", q = false;
      for (let ch of line) {
        if (ch === '"') { q = !q; continue; }
        if (ch === del && !q) { out.push(cur); cur = ""; }
        else { cur += ch; }
      }
      out.push(cur);
      return out;
    }
    function parseCSV(text) {
      text = text.replace(/\r/g, "");
      const lines = text.split("\n").filter(l => l.trim());
      if (!lines.length) return [];
      const sep = (lines[0].split(";").length > lines[0].split(",").length) ? ";" : ",";
      const head = smartSplit(lines.shift(), sep).map(h => h.trim());
      return lines.map(line => {
        const cells = smartSplit(line, sep);
        const obj = {};
        head.forEach((h, i) => {
          let v = (cells[i] || "").trim();
          // Normalize decimal commas
          v = v.replace(/\u00A0/g,' ').trim();
          obj[h] = v;
        });
        return obj;
      });
    }

    // minimal normalization helpers
    function toISO(d) {
      if (!d) return "";
      const s = String(d).trim();
      let m = s.match(/^(\d{4})-(\d{2})-(\d{2})/);
      if (m) return m[0];
      m = s.match(/^(\d{1,2})[.\-/](\d{1,2})[.\-/](\d{2,4})$/);
      if (m) {
        const dd = m[1].padStart(2, "0"),
              mm = m[2].padStart(2, "0"),
              yy = m[3].length === 2 ? ("20" + m[3]) : m[3];
        return yy + "-" + mm + "-" + dd;
      }
      return "";
    }

    // DOM ready setup
    document.addEventListener('DOMContentLoaded', () => {
      applyLang(localStorage.getItem('otd_lang') || 'ru');

      document.querySelectorAll('#langBarMain button').forEach(b => b.addEventListener('click', ()=>applyLang(b.dataset.lang)));
      document.querySelectorAll('.tabs .tab').forEach(t => t.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(x => x.classList.remove('active'));
        document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
        t.classList.add('active');
        document.getElementById(t.dataset.sec).classList.add('active');
      }));

      // initialise state containers
      window.tx = window.tx || [];
      window.bills = window.bills || [];
      window.kasa = window.kasa || [];
    });

    // small helper to format amount with sign + color
    function fmtAmountRaw(raw) {
      const n = asNum(raw);
      if (!Number.isFinite(n)) return '<span>—</span>';
      const sign = n < 0 ? '-' : '+';
      const cls = n < 0 ? 'amt-neg' : 'amt-pos';
      // show 2 decimals, thousands separator
      const abs = Math.abs(n).toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, " ");
      return `<span class="${cls}">${sign} ${abs}</span>`;
    }

    // --- Core app logic (cleaned and consolidated) ---
  </script>

  <!-- rest of large script (logic, OCR, render, etc.) copied largely from your provided file,
       with only the key change: tx row amount uses fmtAmountRaw(...) instead of raw string. -->

  <script>
  (function(){
    // local model
    let tx = [];
    let bills = [];
    let kasa = [];
    let accMeta = {};

    // account inference
    function inferAccounts() {
      const map = {};
      tx.forEach(r => {
        const id = r["ID konta"] || r["IBAN"] || "UNKNOWN";
        const cur = (r["Waluta"] || "PLN").toUpperCase();
        if (!map[id]) {
          map[id] = { id, name: id.slice(0, 12), currency: cur, include: true, type: "Biznes", start: 0 };
        }
      });
      try {
        const saved = JSON.parse(localStorage.getItem("accMeta") || "{}");
        Object.keys(map).forEach(id => {
          if (saved[id]) map[id] = Object.assign(map[id], saved[id]);
        });
      } catch(e){}
      accMeta = map;
      renderAccounts();
    }

    function computeAccountBalance(accId) {
      const rows = tx.filter(r => (r["ID konta"] || r["IBAN"] || "UNKNOWN") === accId);
      const withSaldo = rows.filter(r => r["Saldo po operacji"]);
      if (withSaldo.length) {
        const last = withSaldo[withSaldo.length - 1];
        return asNum(last["Saldo po operacji"]);
      }
      const start = Number((accMeta[accId] || {}).start || 0);
      const sum = rows.reduce((s, r) => s + asNum(r["Kwota"] || r["Kwота"] || r["Kwота"] || r["Kwота"]), 0);
      return start + sum;
    }

    function rate(cur) {
      cur = String(cur || "PLN").toUpperCase();
      if (cur === "PLN") return 1;
      if (cur === "EUR") return asNum(localStorage.getItem("rateEUR") || 4.3);
      if (cur === "USD") return asNum(localStorage.getItem("rateUSD") || 3.95);
      return 1;
    }
    function bankAvailablePLN() {
      let sum = 0;
      Object.values(accMeta).filter(a => a.include).forEach(a => {
        const bal = computeAccountBalance(a.id);
        sum += bal * rate(a.currency);
      });
      return sum;
    }
    function kasaBalance() {
      let bal = 0;
      kasa.forEach(k => {
        if (k.type === "przyjęcie") bal += k.amount;
        if (k.type === "wydanie") bal -= k.amount;
        if (k.type === "zamknięcie") bal = k.amount;
      });
      return bal;
    }
    function availableTotal() {
      const auto = localStorage.getItem("autoCash") === "1";
      const manual = asNum(localStorage.getItem("cashPLN") || 0);
      const kas = kasaBalance();
      return auto ? (bankAvailablePLN() + kas) : (manual + kas);
    }

    // scoring for matching bills to tx
    function normName(s) {
      s = (s || "").toLowerCase().replace(/[.,]/g, " ").replace(/\s+/g, " ").trim();
      const stop = ["sp z oo", "sp. z o.o.", "spolka", "spółka", "sa", "s.a", "ooo"];
      stop.forEach(t => s = s.replace(t, ""));
      return s.trim();
    }
    function nameSimilar(a, b) {
      a = normName(a); b = normName(b);
      if (!a || !b) return 0;
      if (a === b) return 1;
      if (a.includes(b) || b.includes(a)) return 0.8;
      return 0;
    }
    function scoreMatch(bill, tr) {
      let score = 0;
      const bAmt = asNum(bill["Kwота до заплаты"] || bill["Kwота do zapłaty"] || bill["Kwата до заплаты"] || bill["Kwuta do zapl"]);
      const tAmt = Math.abs(asNum(tr["Kwота"] || tr["Kwота"] || tr["Kwота"] || tr["Kwота"]));
      const bCur = String(bill["Waluta"] || "").toUpperCase();
      const tCur = String(tr["Waluta"] || "").toUpperCase();
      if (bAmt > 0 && tAmt > 0 && Math.abs(bAmt - tAmt) < 0.005 && bCur === tCur) score += 60;
      const inv = String(bill["Numer фактуры"] || bill["Numer faktury"] || "").toLowerCase();
      const desc = String(tr["Tytuł/Opis"] || tr["Описание"] || "").toLowerCase();
      if (inv && desc.includes(inv)) score += 25;
      if (nameSimilar(bill["Dostawca"], tr["Kontrahent"] || "") >= 0.8) score += 10;
      if (asNum(tr["Kwота"] || tr["Kwота"] || tr["Kwота"]) < 0) score += 5;
      return { score: Math.min(100, score) };
    }

    function runAI() {
      bills.forEach(b => {
        const status = String(b["Status фактуры"] || b["Status фактуры"] || b["Status faktury"] || "").toLowerCase();
        if (status.includes("opłacone") || status.includes("оплачено")) return;
        let best = null;
        tx.forEach(t => {
          if (String(t["Status transakcji"] || "").toLowerCase() === "sparowane") return;
          if (asNum(t["Kwота"] || t["Kwота"] || t["Kwота"]) >= 0) return;
          const s = scoreMatch(b, t);
          if (!best || s.score > best.s) best = { t, s: s.score };
        });
        if (best && best.s >= 85) {
          best.t["Status transakcji"] = "Sparowane";
          best.t["Powiązana faktura (ID)"] = b["Numer фактуры"];
          b["Status фактуры"] = "Opłacone";
          b["Data płатności"] = today();
        } else if (best && best.s >= 55) {
          b["Kandydат (AI)"] = best.t["ID transakcji"];
          b["AI score"] = best.s;
        } else {
          b["Kandydат (AI)"] = "";
          b["AI score"] = "";
        }
      });
      render();
    }
    function acceptSafe() {
      bills
        .filter(b => Number(b["AI score"] || 0) >= 85)
        .forEach(b => {
          const t = tx.find(t => t["ID transakcji"] === b["Kandydат (AI)"]);
          if (!t) return;
          t["Status transakcji"] = "Sparowane";
          t["Powiązana faktura (ID)"] = b["Numer фактуры"];
          b["Status фактуры"] = "Opłacone";
          b["Data płатności"] = today();
          b["Kandydат (AI)"] = b["AI score"] = "";
        });
      render();
    }

    // normalize row keys for imports
    function normalizeRowKeys(r) {
      const kw = (r["Kwota"] || r["Kwота"] || r["Kwота"] || r["Kwота"] || r.amount || "");
      const kwNum = asNum(kw);
      const out = {
        "Data księgowania": r["Data księgowania"] || r.date || r["Дата"] || today(),
        "ID transakcji": r["ID transakcji"] || r.id || ("IMG-" + Date.now()),
        "ID konta": r["ID konta"] || r.account || r["IBAN"] || "UNKNOWN",
        "Kontrahent": r["Kontrahent"] || r.counterparty || r["Контрагент"] || "",
        "Tytuł/Opis": r["Tytuł/Opis"] || r.desc || r["Описание"] || (r.title || ""),
        // store normalized numeric-like string with dot as decimal
        "Kwota": (Number.isFinite(kwNum) ? kwNum.toFixed(2) : (typeof kw === 'number' ? String(kw) : (kw || ""))),
        "Kwота": (Number.isFinite(kwNum) ? kwNum.toFixed(2) : (typeof kw === 'number' ? String(kw) : (kw || ""))),
        "Waluta": r["Waluta"] || r.currency || "PLN",
        "Status transakcji": r["Status transakcji"] || r.status || "imported",
        "Saldo po operacji": r["Saldo po operacji"] || r.saldo || ""
      };
      return out;
    }

    // OCR function (kept from your file, with preprocessing and robust parsing)
    async function processImageFileFor(targetArrayName, file) {
      if (!file) return;
      const imgURL = URL.createObjectURL(file);

      // preview thumb
      let thumbId = 'lastThumb';
      if (targetArrayName === 'tx') thumbId = 'txLastThumb';
      else if (targetArrayName === 'bills') thumbId = 'billLastThumb';
      const thumb = document.getElementById(thumbId);
      if (thumb) { thumb.src = imgURL; thumb.style.display = "inline-block"; }

      function parseAmountToken(tok) {
        if (!tok) return null;
        const curMatch = tok.match(/\b(PLN|zł|zl|zlot|EUR|USD)\b/i);
        const currency = curMatch ? (curMatch[1].toUpperCase().replace('ZŁ','PLN').replace('ZLOT','PLN')) : 'PLN';
        const numMatch = tok.match(/-?\s*\d{1,3}(?:[ \u00A0]\d{3})*(?:[.,]\d{2})|\d+[.,]\d{2}/);
        if (!numMatch) return null;
        let numStr = numMatch[0].replace(/\s/g,'').replace(/\u00A0/g,'').replace(',', '.').replace('−','-');
        const negative = /-/.test(tok) || /^\-/.test(numStr);
        numStr = numStr.replace(/^\-/, '');
        const value = Number(numStr);
        if (isNaN(value)) return null;
        return { value: negative ? -value : value, raw: numMatch[0], currency, negative };
      }
      function detectDateLine(line) {
        line = (line || "").trim();
        if (!line) return null;
        let m = line.match(/(\d{4})[.\-/](\d{2})[.\-/](\d{2})/);
        if (m) return `${m[1]}-${m[2]}-${m[3]}`;
        m = line.match(/(\d{1,2})[.\-/](\d{1,2})[.\-/](\d{2,4})/);
        if (m) {
          const dd = m[1].padStart(2,'0'), mm = m[2].padStart(2,'0');
          let yy = m[3]; if (yy.length === 2) yy = '20' + yy;
          return `${yy}-${mm}-${dd}`;
        }
        return null;
      }

      try {
        const img = await new Promise((res, rej) => {
          const i = new Image();
          i.onload = () => res(i);
          i.onerror = (e) => rej(e);
          i.src = imgURL;
        });

        // canvas preprocessing - try stronger scaling and improved threshold
        const maxDim = 2600;
        const scale = Math.min(3, Math.max(1, maxDim / Math.max(img.width, img.height)));
        const w = Math.round(img.width * scale), h = Math.round(img.height * scale);
        const canvas = document.createElement('canvas'); canvas.width = w; canvas.height = h;
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(img, 0, 0, w, h);

        try {
          const id = ctx.getImageData(0,0,w,h);
          const d = id.data;
          let sum = 0, sum2 = 0, cnt = 0;
          for (let i=0;i<d.length;i+=4) {
            const r = d[i], g = d[i+1], b = d[i+2];
            const l = Math.round(0.299*r + 0.587*g + 0.114*b);
            d[i] = d[i+1] = d[i+2] = l;
            sum += l; sum2 += l*l; cnt++;
          }
          ctx.putImageData(id,0,0);
          const mean = sum / Math.max(1, cnt);
          const std = Math.sqrt(Math.max(0, sum2/cnt - mean*mean));
          // invert if dark
          if (mean < 120) {
            const id2 = ctx.getImageData(0,0,w,h); const d2 = id2.data;
            for (let i=0;i<d2.length;i+=4) { d2[i] = 255 - d2[i]; d2[i+1] = 255-d2[i+1]; d2[i+2] = 255-d2[i+2]; }
            ctx.putImageData(id2,0,0);
          }
          // adaptive-ish threshold
          const final = ctx.getImageData(0,0,w,h);
          const df = final.data;
          const thresh = Math.max(120, Math.round(mean - std * 0.1));
          for (let i=0;i<df.length;i+=4) {
            const v = df[i];
            const val = v < thresh ? 0 : 255;
            df[i] = df[i+1] = df[i+2] = val;
          }
          ctx.putImageData(final, 0, 0);
        } catch(err) {
          console.warn('preprocess fail, continue', err);
        }

        const dataUrl = canvas.toDataURL('image/png', 1.0);

        // Tesseract worker - DO NOT pass functions into createWorker options (DataCloneError)
        const worker = await Tesseract.createWorker();
        await worker.load();

        try {
          await worker.loadLanguage('pol+eng+rus');
          await worker.initialize('pol+eng+rus');
        } catch(e) {
          console.warn('lang load pol+eng+rus failed, trying pol+eng, then eng', e);
          try { await worker.loadLanguage('pol+eng'); await worker.initialize('pol+eng'); }
          catch(e2) { console.warn('pol+eng failed, trying eng', e2); try { await worker.loadLanguage('eng'); await worker.initialize('eng'); } catch(e3) { console.warn('eng init failed', e3); } }
        }

        const { data: { text } } = await worker.recognize(dataUrl);
        await worker.terminate();

        const cleaned = String(text || "").replace(/\u00A0/g,' ').replace(/\r/g,' ').trim();
        localStorage.setItem('lastOCR', cleaned);

        const lines = cleaned.split('\n').map(l => l.trim()).filter(Boolean);
        const amountREglobal = /-?\s*\d{1,3}(?:[ \u00A0]\d{3})*(?:[.,]\d{2})\s*(PLN|zł|zl|zlot|EUR|USD)?/gi;

        let currentDateIso = null;
        let bufferDesc = [];
        const foundTx = [];

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          const dIso = detectDateLine(line);
          if (dIso) { currentDateIso = dIso; bufferDesc = []; continue; }
          const amounts = [...line.matchAll(amountREglobal)];
          if (amounts && amounts.length) {
            const firstAmtIndex = amounts[0].index || 0;
            let leftPart = line.slice(0, firstAmtIndex).trim();
            let desc = (bufferDesc.length ? bufferDesc.join(' | ') + ' ' : '') + (leftPart ? leftPart : '');
            if (!desc.trim() && i > 0) {
              const prev = lines[i-1].trim();
              if (!detectDateLine(prev) && !prev.match(amountREglobal)) desc = prev;
            }
            for (let j = 0; j < amounts.length; j++) {
              const aRaw = amounts[j][0];
              const parsed = parseAmountToken(aRaw + (amounts[j][1] ? ' ' + amounts[j][1] : ''));
              if (!parsed) continue;
              const leftNearby = line.slice(Math.max(0, (amounts[j].index || 0) - 10), (amounts[j].index || 0) + aRaw.length + 10);
              const outWords = /(wydatek|wydano|wydat|spend|zapłacono|оплачено|płatn|платеж|przelew do|to:|transfer to|paid)/i;
              const inWords = /(wpłata|przychód|przychod|otrzymano|received|przyjęcie|od:|from:|płatn|wpł|przelew od)/i;
              let negative = parsed.value < 0 || /-/.test(aRaw) || outWords.test(leftNearby);
              if (inWords.test(leftNearby)) negative = false;
              const amountVal = negative ? -Math.abs(parsed.value) : Math.abs(parsed.value);

              const txObj = {
                "ID transakcji": "IMG-" + Date.now() + "-" + Math.floor(Math.random()*9999),
                "Data księgowania": currentDateIso || (new Date().toISOString().slice(0,10)),
                "ID konta": "UNKNOWN",
                "Kontrahent": desc ? desc.slice(0,200) : (lines[i+1] || "").slice(0,200),
                "Tytuł/Opis": (desc + (amounts.length > 1 ? ` (part ${j+1}/${amounts.length})` : '')).slice(0,400),
                "Kwota": (amountVal).toFixed(2),
                "Kwota_raw": aRaw,
                "Waluta": (parsed.currency || "PLN").toUpperCase(),
                "Status transakcji": "imported"
              };
              foundTx.push(txObj);
            }
            bufferDesc = [];
            continue;
          }
          bufferDesc.push(line);
          if (bufferDesc.length > 4) bufferDesc.shift();
        }

        // fallback scan
        if (!foundTx.length) {
          const allAmounts = [...cleaned.matchAll(amountREglobal)];
          if (allAmounts && allAmounts.length) {
            for (let k = 0; k < allAmounts.length; k++) {
              const aRaw = allAmounts[k][0];
              const parsed = parseAmountToken(aRaw);
              if (!parsed) continue;
              const idx = allAmounts[k].index || 0;
              const left = cleaned.slice(Math.max(0, idx-80), idx).split('\n').filter(Boolean).pop() || "";
              const right = cleaned.slice(idx + aRaw.length, idx + aRaw.length + 80).split('\n').filter(Boolean)[0] || "";
              const desc = (left || right || "").trim();
              const negative = parsed.value < 0 || /-/.test(aRaw);
              const amountVal = negative ? -Math.abs(parsed.value) : Math.abs(parsed.value);
              foundTx.push({
                "ID transakcji": "IMG-" + Date.now() + "-" + Math.floor(Math.random()*9999),
                "Data księgowania": currentDateIso || (new Date().toISOString().slice(0,10)),
                "ID konta": "UNKNOWN",
                "Kontrahent": desc.slice(0,200),
                "Tytuł/Opis": (desc || "OCR").slice(0,400),
                "Kwota": amountVal.toFixed(2),
                "Waluta": parsed.currency || "PLN",
                "Status transakcji": "imported"
              });
            }
          }
        }

        // commit found rows
        if (foundTx.length) {
          for (const r of foundTx) {
            const normalized = normalizeRowKeys ? normalizeRowKeys(r) : r;
            if (targetArrayName === 'tx') { tx.unshift(normalized); }
            else if (targetArrayName === 'bills') {
              const billRow = {
                "Termin платности": normalized["Data księgowania"],
                "Numer фактуры": "IMG-FV-" + Date.now() + "-" + Math.floor(Math.random()*9999),
                "Dostawca": normalized["Kontrahент"],
                "Kwата до заплаты": Math.abs(asNum(normalized["Kwота"] || normalized["Kwота"] || normalized["Kwota"] || 0)).toFixed(2),
                "Waluta": normalized["Waluta"] || "PLN",
                "Status фактуры": "do zapłaty",
                "Kandydат (AI)": "",
                "AI score": ""
              };
              bills.unshift(billRow);
            }
          }
          try { localStorage.setItem("tx_manual_import", JSON.stringify(tx)); } catch(e) {}
          try { localStorage.setItem("bills_manual_import", JSON.stringify(bills)); } catch(e) {}
          inferAccounts();
          render();
          return;
        }

        // final fallback single-row
        const amtMatch = cleaned.replace(",", ".").match(/(-?\d{1,3}(?:[ .]\d{3})*(?:[.,]\d{2})|\d+[.,]\d{2})\s*(PLN|zł|zl|EUR|USD)?/i);
        const amtStr = amtMatch ? amtMatch[1].replace(/\s/g,'').replace(/\./g,'').replace(',', '.') : null;
        let fallbackAmt = amtStr ? Number(amtStr) : null;
        const dateMatch = cleaned.match(/(\d{2}[.\-/]\d{2}[.\-/]\d{2,4})/);
        const baseObj = {
          "ID transakции": "IMG-" + Date.now(),
          "Data księgования": dateMatch ? toISO(dateMatch[1]) : (currentDateIso || (new Date().toISOString().slice(0,10))),
          "ID kontа": "UNKNOWN",
          "Kontrahent": cleaned.split("\n")[0] || "",
          "Tytuł/Opis": ("OCR: " + cleaned.split("\n").slice(0,3).join(" ")).slice(0,400),
          "Kwота": (fallbackAmt != null ? fallbackAmt.toFixed(2) : ""),
          "Waluta": amtMatch && amtMatch[2] ? amtMatch[2].toUpperCase() : "PLN",
          "Status transakcji": "imported"
        };
        const normalized = normalizeRowKeys ? normalizeRowKeys(baseObj) : baseObj;
        if (targetArrayName === 'tx') {
          tx.unshift(normalized);
          try { localStorage.setItem("tx_manual_import", JSON.stringify(tx)); } catch(e){}
          inferAccounts();
          render();
        } else if (targetArrayName === 'bills') {
          bills.unshift({
            "Termin платности": normalized["Data księgования"],
            "Numer фактуры": "IMG-FV-" + Date.now(),
            "Dостawca": normalized["Kontrahент"],
            "Kwата до заплаты": Math.abs(asNum(normalized["Kwота"] || 0)).toFixed(2),
            "Waluta": normalized["Waluta"] || "PLN",
            "Status фактуры": "do zapłaty",
            "Kandydат (AI)": "",
            "AI score": ""
          });
          try { localStorage.setItem("bills_manual_import", JSON.stringify(bills)); } catch(e){}
          render();
        }

      } catch(err) {
        console.error("OCR error (processImageFileFor):", err);
        alert("Не удалось распознать скрин: " + (err && err.message ? err.message : String(err)));
      }
    }

    // wire image inputs (DOMContentLoaded also sets but keep idempotent)
    document.addEventListener('DOMContentLoaded', () => {
      const txImage = document.getElementById('txImage');
      if (txImage) {
        txImage.addEventListener('change', async e => {
          const files = Array.from(e.target.files || []);
          if (!files.length) return;
          document.getElementById("lastSync").textContent = "Синхронизация: " + new Date().toLocaleString();
          for (const f of files) {
            await processImageFileFor('tx', f);
          }
          e.target.value = '';
        });
      }
      const billImage = document.getElementById('billImage');
      if (billImage) {
        billImage.addEventListener('change', async e => {
          const files = Array.from(e.target.files || []);
          if (!files.length) return;
          for (const f of files) {
            await processImageFileFor('bills', f);
          }
          e.target.value = '';
        });
      }
      const cashPhoto = document.getElementById('cashPhoto');
      if (cashPhoto) {
        cashPhoto.addEventListener('change', async e => {
          const f = e.target.files[0]; if (!f) return;
          await processImageFileFor('tx', f);
          e.target.value = '';
        });
      }
    });

    // render / UI functions (kept concise)
    function renderKasa() {
      const tb = document.querySelector("#kasaTable tbody");
      if (!tb) return;
      tb.innerHTML = "";
      kasa.forEach((k, i) => {
        const tr = document.createElement("tr");
        tr.innerHTML = `<td>${i + 1}</td><td>${k.date}</td><td>${k.type}</td><td>${k.amount.toFixed(2)}</td><td>${k.source || ""}</td><td>${k.comment || ""}</td>`;
        tb.appendChild(tr);
      });
    }

    function renderAccounts() {
      const tb = document.querySelector("#autoAcc tbody");
      if (!tb) return;
      tb.innerHTML = "";
      Object.values(accMeta).forEach(a => {
        const bal = computeAccountBalance(a.id);
        const tr = document.createElement("tr");
        tr.innerHTML = `<td>${a.id}</td>
          <td>
            <select data-id="${a.id}" class="acc-type">
              <option ${a.type === "Biznes" ? "selected" : ""}>Biznes</option>
              <option ${a.type === "Osobisty" ? "selected" : ""}>Osobisty</option>
            </select>
          </td>
          <td>
            <select data-id="${a.id}" class="acc-cur">
              <option ${a.currency === "PLN" ? "selected" : ""}>PLN</option>
              <option ${a.currency === "EUR" ? "selected" : ""}>EUR</option>
              <option ${a.currency === "USD" ? "selected" : ""}>USD</option>
            </select>
          </td>
          <td>${bal.toFixed(2)}</td>
          <td><input type="number" step="0.01" value="${a.start || 0}" class="acc-start" data-id="${a.id}" /></td>
          <td><input type="checkbox" class="acc-include" data-id="${a.id}" ${a.include ? "checked" : ""} /></td>`;
        tb.appendChild(tr);
      });
      tb.querySelectorAll(".acc-type").forEach(el => el.addEventListener("change", e => {
        const id = e.target.dataset.id;
        accMeta[id].type = e.target.value;
        saveAccMeta();
        render();
      }));
      tb.querySelectorAll(".acc-cur").forEach(el => el.addEventListener("change", e => {
        const id = e.target.dataset.id;
        accMeta[id].currency = e.target.value;
        saveAccMeta();
        render();
      }));
      tb.querySelectorAll(".acc-start").forEach(el => el.addEventListener("change", e => {
        const id = e.target.dataset.id;
        accMeta[id].start = asNum(e.target.value);
        saveAccMeta();
        render();
      }));
      tb.querySelectorAll(".acc-include").forEach(el => el.addEventListener("change", e => {
        const id = e.target.dataset.id;
        accMeta[id].include = e.target.checked;
        saveAccMeta();
        render();
      }));
    }
    function saveAccMeta() { localStorage.setItem("accMeta", JSON.stringify(accMeta)); }

    // Kasa CRUD
    function loadKasa() {
      try { kasa = JSON.parse(localStorage.getItem("kasa") || "[]"); } catch(e) { kasa = []; }
    }
    function saveKasa() { localStorage.setItem("kasa", JSON.stringify(kasa)); }
    function addKasa(type, amount, comment, source) {
      if (amount == null || isNaN(amount)) return alert("Сумма");
      kasa.push({ id: Date.now(), date: today(), type, amount: Number(amount), comment: comment || "", source: source || "ручной" });
      saveKasa();
      render();
      renderKasa();
    }

    // plan and rendering (kept from original, with tolerant keys)
    function toDueList(mode) {
      const t = today();
      const excl = document.getElementById("excludeBlacklist")?.checked;
      return bills.filter(r => {
        const s = String(r["Status фактуры"] || r["Status faktury"] || r["Status faktury"] || "").toLowerCase();
        if (!["do zapłaty", "przeterminowane", "к оплате", "просрочено"].includes(s)) return false;
        const d = toISO(r["Termin платности"] || r["Termin платności"] || r["Termin платежи"] || r["Termin платежi"]);
        if (!d) return false;
        if (mode === "today") return d === t;
        if (mode === "7d") {
          const dd = new Date(d), tt = new Date(t);
          return (dd - tt) / (1000 * 3600 * 24) <= 7;
        }
        return true;
      }).filter(r => {
        if (String(r["Waluta"] || r["Walута"] || "").toUpperCase() !== "PLN") return false;
        if (excl) {
          const blist = (localStorage.getItem("blacklist") || "").toLowerCase();
          if (blist && r["Dostawca"] && blist.split(",").some(name => r["Dostawca"].toLowerCase().includes(name.trim()))) {
            return false;
          }
        }
        return true;
      });
    }

    function buildPlan() {
      const mode = document.getElementById("planFilter").value;
      const cand = toDueList(mode).sort((a, b) => {
        const da = new Date(toISO(a["Termin платности"] || a["Termin платności"] || a["Termin платежи"] || a["Termin платежi"]));
        const db = new Date(toISO(b["Termin платности"] || b["Termin платности"] || b["Termin платежи"] || b["Termin платежi"]));
        const lateA = da < new Date(today());
        const lateB = db < new Date(today());
        if (lateA !== lateB) return lateB - lateA;
        return asNum(b["Kwота до заплаты"] || b["Kwута до заплаты"] || b["Kwата до заплаты"] || 0) - asNum(a["Kwота до заплаты"] || a["Kwута до заплаты"] || 0);
      });
      let left = availableTotal();
      const plan = [];
      for (const r of cand) {
        const amt = asNum(r["Kwота до заплаты"] || r["Kwота do zapłaty"] || r["Kwата до заплаты"] || 0);
        if (amt <= left) {
          plan.push({
            r,
            amt,
            reason: (toISO(r["Termin платности"] || r["Termin платności"] || r["Termin платежи"]) < today() ? "просрочка" : "срок")
          });
          left -= amt;
        }
      }
      return { plan, left, avail: availableTotal() };
    }

    function renderPlan() {
      const p = buildPlan();
      const tb = document.getElementById("planTable").querySelector("tbody");
      tb.innerHTML = "";
      p.plan.forEach((x, i) => {
        const tr = document.createElement("tr");
        tr.innerHTML = `<td>${i + 1}</td><td>${x.r["Numer фактуры"] || x.r["Numer faktury"] || ""}</td><td>${x.r["Dostawca"] || ""}</td><td>${toISO(x.r["Termin платности"] || x.r["Termin платности"] || x.r["Termin платежи"])}</td><td>${x.amt.toFixed(2)}</td><td>${x.reason}</td>`;
        tb.appendChild(tr);
      });
      const metaText = p.plan.length 
        ? `Потратим ${(p.avail - p.left).toFixed(2)} из ${p.avail.toFixed(2)} PLN. Останется ${p.left.toFixed(2)} PLN.` 
        : "План пуст или денег нет.";
      document.getElementById("planMeta").textContent = metaText;
    }

    function computeMinPay() {
      const t = today();
      const pct = asNum(localStorage.getItem("penaltyPct") || 0.05) / 100.0;
      const cand = bills.filter(r => 
        String((r["Waluta"] || r["Walута"] || "").toUpperCase()) === "PLN" &&
        toISO(r["Termin платности"] || r["Termin платності"] || r["Termin платежи"]) <= t &&
        ["do zapłaty", "przeterminowane", "к оплате", "просрочено"].includes(String(r["Status фактуры"] || r["Status faktury"] || r["Status faktury"] || "").toLowerCase())
      ).map(r => (({
        r,
        amt: asNum(r["Kwота до заплаты"] || r["Kwута до заплаты"] || r["Kwата до заплаты"] || 0),
        risk: asNum(r["Kwота до заплаты"] || r["Kwута до заплаты"] || 0) * pct
      }))).sort((a, b) => b.risk - a.risk || b.amt - a.amt);
      return cand[0] || null;
    }
    function renderMinPay() {
      const m = computeMinPay();
      const el = document.getElementById("minPayBox");
      if (!m) {
        el.textContent = "—";
        return;
      }
      el.textContent = `Оплатить ${m.r["Numer фактуры"] || m.r["Numer faktury"]} (${m.r["Dostawca"]}) на ${m.amt.toFixed(2)} PLN. Штраф/день ~ ${m.risk.toFixed(2)} PLN.`;
    }

    function renderForecast() {
      const t = new Date(today());
      const list = toDueList("7d").map(r => ({ date: new Date(toISO(r["Termin платности"] || r["Termin платності"] || r["Termin платежи"])), amt: asNum(r["Kwота до заплаты"] || r["Kwута до заплаты"] || 0) }));
      const days = [...Array(7)].map((_, i) => new Date(t.getTime() + i * 86400000));
      let left = availableTotal();
      const out = days.map(d => ({ d, due: 0, after: 0 }));
      list.forEach(x => {
        const idx = Math.min(6, Math.max(0, Math.floor((x.date - t) / 86400000)));
        out[idx].due += x.amt;
      });
      out.forEach(o => { left -= o.due; o.after = left; });
      const wrap = document.getElementById("forecastBars");
      wrap.innerHTML = "";
      out.forEach(o => {
        const div = document.createElement("div");
        div.className = "bar" + (o.after < 0 ? " neg" : "");
        const h = document.createElement("div");
        h.className = "h";
        h.style.height = (Math.min(120, Math.abs(o.after) / 100) * 0.8 + 18) + "px";
        div.innerHTML = "<small>" + o.d.toISOString().slice(5, 10) + "</small>";
        div.appendChild(h);
        const v = document.createElement("div");
        v.textContent = (o.after < 0 ? "-" : "") + Math.abs(o.after).toFixed(0) + " PLN";
        div.appendChild(v);
        wrap.appendChild(div);
      });
      const firstNeg = out.find(x => x.after < 0);
      document.getElementById("forecastMeta").textContent = firstNeg
        ? `Гэп через ${out.indexOf(firstNeg) + 1} дн.: не хватает ${Math.abs(firstNeg.after).toFixed(2)} PLN.`
        : "На 7 дней хватает кассы.";
    }

    // main render
    function render() {
      // load from local copies if present
      try { tx = JSON.parse(localStorage.getItem("tx_manual_import") || "[]").concat(tx || []); } catch(e){}
      try { bills = JSON.parse(localStorage.getItem("bills_manual_import") || "[]").concat(bills || []); } catch(e){}
      try { accMeta = Object.assign({}, JSON.parse(localStorage.getItem("accMeta") || "{}"), accMeta || {}); } catch(e){}

      const dueToday = bills.filter(r => {
        const s = String(r["Status фактуры"] || r["Status faktury"] || r["Status faktury"] || "").toLowerCase();
        return ["do zapłaty", "przeterminowane", "к оплате", "просрочено"].includes(s) && toISO(r["Termin платности"] || r["Termin платности"] || r["Termin платежи"]) === today();
      }).length;
      const unmatch = tx.filter(r => String(r["Status transakcji"] || r["Status транзакции"] || "").toLowerCase() !== "sparowane").length;
      document.getElementById("kpiDue").textContent = dueToday;
      document.getElementById("kpiUnmatch").textContent = unmatch;
      const bankPLN = bankAvailablePLN();
      document.getElementById("kpiBank").textContent = bankPLN.toFixed(2);
      const kas = kasaBalance();
      document.getElementById("kpiCash").textContent = kas.toFixed(2);
      const avail = availableTotal();
      document.getElementById("kpiAvail").textContent = avail.toFixed(2);

      // sumDueToday
      const sumDueToday = bills.filter(r =>
        String((r["Walута"] || r["Walута"] || "").toUpperCase()) === "PLN" &&
        toISO(r["Termin платности"] || r["Termin платности"] || r["Termin платежи"]) <= today() &&
        ["do zapłаты", "przeterminowane", "к оплате", "просрочено"].includes(String(r["Status фактуры"] || r["Status faktury"] || r["Status faktury"] || "").toLowerCase())
      ).reduce((s, r) => s + asNum(r["Kwота до заплаты"] || r["Kwота до заплаты"] || r["Kwата до заплаты"] || 0), 0);
      document.getElementById("kpiGap").textContent = Math.max(0, sumDueToday - avail).toFixed(2);

      // Transactions table
      const txBody = document.getElementById("txTable").querySelector("tbody");
      txBody.innerHTML = "";
      tx.forEach(r => {
        const tr = document.createElement("tr");
        // use fmtAmountRaw to display amount with +/- and color
        const amountHtml = fmtAmountRaw(r["Kwота"] || r["Kwota"] || r["Kwota"] || r["Kwота"] || r["Kwota_raw"] || r["Kwота"] || 0);
        tr.innerHTML = `<td>${toISO(r["Data księgowania"])}</td>
                        <td>${(r["ID konta"] || r["IBAN"] || "—")}</td>
                        <td>${(r["Kontrahent"] || "")}</td>
                        <td>${(r["Tytuł/Opis"] || r["Opis operacji"] || "")}</td>
                        <td>${amountHtml}</td>
                        <td>${r["Waluta"] || ""}</td>
                        <td>${r["Status transakcji"] || ""}</td>`;
        txBody.appendChild(tr);
      });

      // Invoices table
      const billBody = document.getElementById("billTable").querySelector("tbody");
      billBody.innerHTML = "";
      const scope = document.getElementById("billScope").value;
      const onlyOverdue = document.getElementById("billOverdueOnly")?.checked;
      bills.forEach(r => {
        const s = String(r["Status фактуры"] || r["Status faktury"] || r["Status faktury"] || "").toLowerCase();
        if (!["do zapłaty", "przeterminowane", "к оплате", "просрочено"].includes(s)) return;
        if (onlyOverdue && !(s.includes("przetermin") || s.includes("проср"))) return;
        const d = toISO(r["Termin платности"] || r["Termin платności"] || r["Termin платежи"]);
        if (scope === "today" && d !== today()) return;
        if (scope === "7d") {
          const dd = new Date(d), tt = new Date(today());
          if ((dd - tt) / (1000 * 3600 * 24) > 7) return;
        }
        const cls = (s.includes("przetermin") || s.includes("проср")) ? "overdue" : "due";
        const cand = r["Kandydат (AI)"] || r["Kandydат (AI)"] || "";
        const score = r["AI score"] || "";
        const tr = document.createElement("tr");
        tr.innerHTML = `<td>${d}</td>
                        <td>${r["Numer фактуры"] || r["Numer faktury"] || ""}</td>
                        <td>${r["Dostawca"] || ""}</td>
                        <td>${(r["Kwота до заплаты"] || r["Kwута до заплаты"] || r["Kwата до заплаты"] || "")}</td>
                        <td>${r["Waluta"] || ""}</td>
                        <td><span class="badge ${cls}">${r["Status фактуры"] || r["Status faktury"] || ""}</span></td>
                        <td>${cand ? ('<span class="badge cand">' + cand + '</span>') : '—'}</td>
                        <td>${score ? ('<span class="badge ai">' + score + '</span>') : '—'}</td>
                        <td>${cand ? ('<button class="btn secondary btn-accept" data-id="' + (r["Numer фактуры"] || r["Numer faktury"] || "") + '">Принять</button>') : '—'}</td>`;
        billBody.appendChild(tr);
      });
      document.querySelectorAll(".btn-accept").forEach(b =>
        b.addEventListener("click", () => acceptOne(b.getAttribute("data-id")))
      );

      renderMinPay();
      renderForecast();
      renderAccounts();
      renderKasa();
    }

    function acceptOne(id) {
      const b = bills.find(x => (x["Numer фактуры"] || x["Numer faktury"] || "") === id);
      if (!b) return;
      const t = tx.find(x => (x["ID transakции"] || "") === (b["Kandydат (AI)"] || ""));
      if (!t) return;
      t["Status transakcji"] = "Sparowane";
      t["Powiązana faktura (ID)"] = b["Numer фактуры"] || b["Numer фактуры"];
      b["Status фактуры"] = "Opłacone";
      b["Data płатności"] = today();
      b["Kandydат (AI)"] = b["AI score"] = "";
      render();
    }

    // event bindings and init
    document.addEventListener('DOMContentLoaded', () => {
      document.getElementById("runAI").addEventListener("click", runAI);
      document.getElementById("acceptSafe").addEventListener("click", acceptSafe);
      document.getElementById("makePlan").addEventListener("click", renderPlan);
      document.getElementById("applyPlan").addEventListener("click", applyPlan);
      document.getElementById("applyMinPay").addEventListener("click", () => {
        const m = computeMinPay();
        if (!m) return alert("Нет кандидатов");
        m.r["Status фактуры"] = "Opłacone";
        m.r["Data płатności"] = today();
        render();
      });
      document.getElementById("planFilter").addEventListener("change", renderPlan);
      document.getElementById("billScope").addEventListener("change", render);
      document.getElementById("excludeBlacklist")?.addEventListener("change", () => { renderPlan(); render(); });
      document.getElementById("billOverdueOnly")?.addEventListener("change", render);
      document.getElementById("exportPDF").addEventListener("click", () => window.print());
      document.getElementById("syncNow").addEventListener("click", async () => {
        try {
          const u1 = localStorage.getItem("txUrl") || "";
          const u2 = localStorage.getItem("billUrl") || "";
          if (u1) {
            const res = await fetch(u1, { cache: 'no-store' });
            const txt = await res.text();
            tx = parseCSV(txt);
          }
          if (u2) {
            const res2 = await fetch(u2, { cache: 'no-store' });
            const txt2 = await res2.text();
            bills = parseCSV(txt2);
          }
          inferAccounts();
          render();
          document.getElementById("lastSync").textContent = "Синхронизация: " + new Date().toLocaleString();
        } catch(e) {
          document.getElementById("lastSync").textContent = "Ошибка: " + (e && e.message ? e.message : String(e));
        }
      });

      document.getElementById("txFile")?.addEventListener("change", async e => {
        const f = e.target.files[0];
        if (!f) return;
        tx = parseCSV(await f.text());
        inferAccounts();
        render();
      });
      document.getElementById("billFile")?.addEventListener("change", async e => {
        const f = e.target.files[0];
        if (!f) return;
        bills = parseCSV(await f.text());
        render();
      });
      document.getElementById("saveTxUrl")?.addEventListener("click", () => {
        localStorage.setItem("txUrl", document.getElementById("txUrl").value.trim());
        alert("Сохранено URL wyciąga");
      });
      document.getElementById("saveBillUrl")?.addEventListener("click", () => {
        localStorage.setItem("billUrl", document.getElementById("billUrl").value.trim());
        alert("Сохранено URL faktur");
      });

      // cash controls
      document.getElementById("addIn").addEventListener("click", () =>
        addKasa("przyjęcie", asNum(document.getElementById("quickAmt").value), document.getElementById("quickNote").value, "ручной")
      );
      document.getElementById("addOut").addEventListener("click", () =>
        addKasa("wydanie", asNum(document.getElementById("quickAmt").value), document.getElementById("quickNote").value, "ручной")
      );
      document.getElementById("cashClose").addEventListener("click", () => {
        const a = prompt("Итог в кассе (PLN):", kasaBalance().toFixed(2));
        if (a === null) return;
        addKasa("zamknięcie", asNum(a), "close", "ручной");
      });
      document.getElementById("q50").addEventListener("click", () => {
        document.getElementById("quickAmt").value = (Number(document.getElementById("quickAmt").value || 0) + 50).toFixed(2);
      });
      document.getElementById("q100").addEventListener("click", () => {
        document.getElementById("quickAmt").value = (Number(document.getElementById("quickAmt").value || 0) + 100).toFixed(2);
      });
      document.getElementById("q200").addEventListener("click", () => {
        document.getElementById("quickAmt").value = (Number(document.getElementById("quickAmt").value || 0) + 200).toFixed(2);
      });

      // Voice recognition
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      let rec = null;
      if (SR) {
        rec = new SR();
        rec.continuous = false;
        rec.interimResults = false;
        rec.maxAlternatives = 1;
        rec.lang = localStorage.getItem("speechLang") || "pl-PL";
        rec.onstart = () => {
          if (document.querySelector(".mic")) document.querySelector(".mic").classList.add("on");
          document.getElementById("micStatus").textContent = `🎙️ Слушаю... (${rec.lang})`;
        };
        rec.onend = () => {
          if (document.querySelector(".mic")) document.querySelector(".mic").classList.remove("on");
        };
        rec.onresult = (e) => {
          const text = (e.results[0][0].transcript || "").toLowerCase();
          document.getElementById("micStatus").textContent = "🎙️ Распознано: " + text;
          const numMatch = text.match(/(\d+[.,]?\d*)\s*(zł|pln)?/);
          const num = numMatch ? numMatch[1] : null;
          const isOut = /(wyda|minus|wydat|выда|минус|расход)/.test(text);
          const isIn = /(przyj|plus|wpływ|принять|плюс|приход)/.test(text) || !isOut;
          const note = text.replace(/(\d+[.,]?\d*\s*(zł|pln)?)/, "").trim();
          if (!num) {
            document.getElementById("micStatus").textContent = "🎙️ Сумму не нашёл";
            return;
          }
          addKasa(isOut ? "wydanie" : "przyjęcie", asNum(num), note || "голос", "voice");
        };
      }
      document.getElementById("micBtn").addEventListener("click", () => {
        if (!rec) { alert("Голосовой ввод требует Chrome + HTTPS/localhost."); return; }
        try {
          const sel = document.getElementById("speechLang");
          if (sel) {
            rec.lang = sel.value;
            localStorage.setItem("speechLang", rec.lang);
          }
          rec.start();
        } catch(e) {
          document.getElementById("micStatus").textContent = "🎙️ Не смог запустить: " + e.message;
        }
      });
      document.getElementById("micTest").addEventListener("click", () => {
        document.getElementById("micStatus").textContent = "🎙️ Тест: прийнято 120 на кассу (симуляция)";
        addKasa("przyjęcie", 120, "симуляция", "test");
      });

      // OCR for receipt (simple path using the function above)
      document.getElementById("cashPhoto")?.addEventListener("change", async e => {
        const f = e.target.files[0];
        if (!f) return;
        await processImageFileFor('tx', f);
      });

      // Settings handlers
      document.getElementById("applySettings").addEventListener("click", () => {
        localStorage.setItem("cashPLN", document.getElementById("cashPLN").value || "0");
        localStorage.setItem("penaltyPct", document.getElementById("penaltyPct").value || "0.05");
        localStorage.setItem("intervalMin", document.getElementById("intervalMin").value || "10");
        localStorage.setItem("rateEUR", document.getElementById("rateEUR").value || "4.30");
        localStorage.setItem("rateUSD", document.getElementById("rateUSD").value || "3.95");
        localStorage.setItem("blacklist", document.getElementById("blacklist").value || "");
        localStorage.setItem("autoCash", document.getElementById("autoCash").checked ? "1" : "0");
        document.getElementById("modeCash").textContent = (localStorage.getItem("otd_lang") || "ru") === "ru"
          ? "Режим: " + (document.getElementById("autoCash").checked ? "авто" : "ручной")
          : "Mode: " + (document.getElementById("autoCash").checked ? "auto" : "manual");
        render();
      });
      document.getElementById("exportCfg").addEventListener("click", () => {
        const cfg = {
          txUrl: localStorage.getItem("txUrl") || "",
          billUrl: localStorage.getItem("billUrl") || "",
          cashPLN: localStorage.getItem("cashPLN") || "0",
          penaltyPct: localStorage.getItem("penaltyPct") || "0.05",
          intervalMin: localStorage.getItem("intervalMin") || "10",
          rateEUR: localStorage.getItem("rateEUR") || "4.30",
          rateUSD: localStorage.getItem("rateUSD") || "3.95",
          blacklist: localStorage.getItem("blacklist") || "",
          autoCash: localStorage.getItem("autoCash") || "0",
          accMeta: localStorage.getItem("accMeta") || "{}"
        };
        const blob = new Blob([JSON.stringify(cfg, null, 2)], { type: "application/json" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "onetapday_settings.json";
        a.click();
      });
      document.getElementById("importCfg")?.addEventListener("change", async e => {
        const f = e.target.files[0];
        if (!f) return;
        const cfg = JSON.parse(await f.text());
        Object.entries(cfg).forEach(([k, v]) => localStorage.setItem(k, typeof v === "string" ? v : JSON.stringify(v)));
        location.reload();
      });

      // Pilot admin actions (kept simple) - same as before...
      (function pilotUI() {
        function getPilot() { try { return JSON.parse(localStorage.getItem("otd_pilot") || "{}"); } catch(e){ return {}; } }
        function setPilot(s) { try { localStorage.setItem("otd_pilot", JSON.stringify(s)); } catch(e){} }
        function isoDate(d) { const x = new Date(d); return isNaN(x) ? "—" : x.toISOString().slice(0,10); }
        function daysLeft(endIso) { if (!endIso) return 0; const e = new Date(endIso), n = new Date(); return Math.max(0, Math.ceil((e - n) / 86400000)); }
        function updatePilotUI() {
          const s = getPilot();
          const st = s.status || "none";
          let desc = "—";
          if (st === "none") desc = "ожидается оплата депозита";
          if (st === "deposit_paid") desc = "депозит оплачен";
          if (st === "active") desc = "пилот активен";
          if (st === "ended") desc = "пилот завершён";
          if (st === "discount_active") desc = "скидка активна";
          const mini = document.getElementById("pilotMini"); if (mini) mini.textContent = "Статус: " + desc;
          const ps = document.getElementById("pilotStart"); if (ps) ps.textContent = s.startAt ? isoDate(s.startAt) : "—";
          const pe = document.getElementById("pilotEnd"); if (pe) pe.textContent = s.endAt ? isoDate(s.endAt) : "—";
          const pc = document.getElementById("pilotCountdown"); if (pc) pc.textContent = (st === "active" && s.endAt) ? (" · осталось " + daysLeft(s.endAt) + " дн.") : "";
          const du = document.getElementById("discountUntil"); if (du) du.textContent = s.discountUntil ? isoDate(s.discountUntil) : "—";
          const userEmail = localStorage.getItem("otd_user") || "";
          const isAdmin = userEmail && (userEmail === "1tapday@gmail.com");
          const btnMark = document.getElementById("btnMarkPaid"), btnStart = document.getElementById("btnStartPilot"), btnReset = document.getElementById("btnResetPilot"), btnAct = document.getElementById("btnActivateDiscount");
          if (btnMark) btnMark.style.display = isAdmin ? "inline-block" : "none";
          if (btnStart) btnStart.style.display = isAdmin ? "inline-block" : "none";
          if (btnReset) btnReset.style.display = isAdmin ? "inline-block" : "none";
          if (btnAct) btnAct.style.display = (st === "ended" && isAdmin) ? "inline-block" : "none";
        }
        document.addEventListener("click", (e) => {
          const id = e.target && e.target.id;
          if (!id) return;
          let s = getPilot();
          if (id === "btnMarkPaid") {
            fetch("/mark-paid", { method: "POST" })
              .then(res => res.json()).then(data => {
                s.status = "deposit_paid"; s.paidAt = new Date().toISOString(); setPilot(s); updatePilotUI();
              }).catch(()=>{ s.status = "deposit_paid"; s.paidAt = new Date().toISOString(); setPilot(s); updatePilotUI(); });
          }
          if (id === "btnStartPilot") {
            fetch("/start-pilot", { method: "POST" })
              .then(res => res.json()).then(data => {
                s.status = "active"; s.startAt = new Date().toISOString(); const d = new Date(); d.setMonth(d.getMonth() + 2); s.endAt = d.toISOString(); setPilot(s); updatePilotUI();
              }).catch(()=>{ s.status = "active"; s.startAt = new Date().toISOString(); const d = new Date(); d.setMonth(d.getMonth() + 2); s.endAt = d.toISOString(); setPilot(s); updatePilotUI(); });
          }
          if (id === "btnActivateDiscount") {
            fetch("/activate-discount", { method: "POST" })
              .then(res => res.json()).then(data => {
                s.status = "discount_active"; s.discountSince = new Date().toISOString(); const e2 = new Date(); e2.setMonth(e2.getMonth() + 12); s.discountUntil = e2.toISOString(); setPilot(s); updatePilotUI();
              }).catch(()=>{ s.status = "discount_active"; s.discountSince = new Date().toISOString(); const e2 = new Date(); e2.setMonth(e2.getMonth() + 12); s.discountUntil = e2.toISOString(); setPilot(s); updatePilotUI(); });
          }
          if (id === "btnResetPilot") {
            localStorage.removeItem("otd_pilot");
            updatePilotUI();
          }
        }, false);
        setInterval(() => {
          const s = JSON.parse(localStorage.getItem("otd_pilot") || "{}");
          if ((s.status || "") === "active") updatePilotUI();
        }, 60000);
        updatePilotUI();
      })();

      // init load
      (function init() {
        loadKasa();
        try { accMeta = JSON.parse(localStorage.getItem("accMeta") || "{}"); } catch(e) { accMeta = {}; }
        try { tx = JSON.parse(localStorage.getItem("tx_manual_import") || "[]").concat(tx); } catch(e){}
        try { bills = JSON.parse(localStorage.getItem("bills_manual_import") || "[]").concat(bills); } catch(e){}
        renderKasa();
        document.getElementById("txUrl").value = localStorage.getItem("txUrl") || "";
        document.getElementById("billUrl").value = localStorage.getItem("billUrl") || "";
        document.getElementById("cashPLN").value = localStorage.getItem("cashPLN") || "5000";
        document.getElementById("penaltyPct").value = localStorage.getItem("penaltyPct") || "0.05";
        document.getElementById("intervalMin").value = localStorage.getItem("intervalMin") || "10";
        document.getElementById("rateEUR").value = localStorage.getItem("rateEUR") || "4.30";
        document.getElementById("rateUSD").value = localStorage.getItem("rateUSD") || "3.95";
        document.getElementById("blacklist").value = localStorage.getItem("blacklist") || "";
        document.getElementById("autoCash").checked = localStorage.getItem("autoCash") === "1";
        const saved = localStorage.getItem("speechLang");
        if (saved) document.getElementById("speechLang").value = saved;
        document.getElementById("modeCash").textContent = (localStorage.getItem("otd_lang") || "ru") === "ru"
          ? "Режим: " + (document.getElementById("autoCash").checked ? "авто" : "ручной")
          : "Mode: " + (document.getElementById("autoCash").checked ? "auto" : "manual");
        inferAccounts();
        render();
      })();
    });
  })();
  </script>

  <script>
  (async function(){
    function fmtTime(ms){ if(ms <= 0) return '00:00:00'; const h = Math.floor(ms/3600000), m = Math.floor(ms%3600000/60000), s = Math.floor(ms%60000/1000); return String(h).padStart(2,'0')+':'+String(m).padStart(2,'0')+':'+String(s).padStart(2,'0'); }
    async function whoami(){ try { const r = await fetch('/me', { credentials: 'include' }); if (!r.ok) return null; const json = await r.json(); return json.user || null;} catch(e){ return null; } }
    const user = await whoami();
    if (!user) {
      const statusEl = document.getElementById('mvp-status') || (function(){ const e = document.createElement('div'); e.id='mvp-status'; e.style.margin='8px'; document.body.prepend(e); return e; })();
      statusEl.innerHTML = 'Нет доступа. <button id="payNow">Оплатить 2 месяца</button>';
      document.getElementById('payNow').addEventListener('click', async ()=>{ const r = await fetch('/create-checkout-session', { method: 'POST', credentials: 'include' }).catch(()=>null); const j = r ? await r.json().catch(()=>null) : null; const redirect = (j && (j.url || j.sessionUrl || (j.session && j.session.url))) || null; if (redirect) window.location.href = redirect; else alert('Не удалось создать Stripe-сессию.'); });
      return;
    }
    const statusEl = document.getElementById('mvp-status') || (function(){ const e = document.createElement('div'); e.id='mvp-status'; e.style.margin='8px'; document.body.prepend(e); return e; })();
    const endISO = user.endAt || user.demo_until || user.demoUntil;
    if (endISO) {
      let until = Date.parse(endISO); if (isNaN(until)) until = Date.now() + 24*60*60*1000;
      statusEl.textContent = 'Демо активировано — осталось ' + fmtTime(until - Date.now());
      const t = setInterval(()=>{ const diff = until - Date.now(); if (diff <= 0) { clearInterval(t); statusEl.innerHTML = 'Демо завершено. <button id="payAfterDemo">Оплатить сейчас</button>'; document.getElementById('payAfterDemo').addEventListener('click', async ()=>{ const r = await fetch('/create-checkout-session', { method: 'POST', credentials: 'include' }); const j = await r.json().catch(()=>null); const redirect = (j && (j.url || j.sessionUrl || j.session && j.session.url)) || null; if (redirect) window.location.href = redirect; else alert('Не удалось создать платежную сессию. Смотри логи.'); }); return; } else statusEl.textContent = 'Демо активировано — осталось ' + fmtTime(diff) + ' (после окончания будет предложена оплата)'; }, 1000);
    } else {
      statusEl.innerHTML = 'Нет доступа. <button id="payNow">Оплатить 2 месяца</button>';
      document.getElementById('payNow').addEventListener('click', async ()=>{ const r = await fetch('/create-checkout-session', { method: 'POST', credentials: 'include' }); const j = await r.json().catch(()=>null); const redirect = (j && (j.url || j.sessionUrl || j.session && j.session.url)) || null; if (redirect) window.location.href = redirect; else alert('Не удалось создать Stripe-сессию.'); });
    }
  })();
  </script><!-- ======= OneTapDay quick restore patch =======
     Paste this block BEFORE </body> in your HTML file.
     It is defensive and will not override your existing functions.
=============================================== -->
<script>
(function(){
  // defensive helper
  const $ = sel => document.querySelector(sel);
  const $$ = sel => Array.from(document.querySelectorAll(sel));
  const has = (id) => !!document.getElementById(id);
  const log = (...a) => { try { console.log('[OTD-PATCH]',...a); } catch(e){} };

  function safeCall(name, ...args){
    try{
      if (typeof window[name] === 'function') return window[name](...args);
      return null;
    }catch(e){ console.warn('safeCall failed', name, e); return null; }
  }

  // --- Tabs fix: rebind tabs so no tab leaves a black screen ---
  function initTabs(){
    const tabs = $$('.tabs .tab');
    if (!tabs.length) return;
    tabs.forEach(t => {
      t.removeEventListener('click', t._otd_cb);
      const cb = () => {
        $$(' .tabs .tab').forEach(x=>x.classList.remove('active'));
        $$('.section').forEach(s=>s.classList.remove('active'));
        t.classList.add('active');
        const sec = t.dataset.sec || t.getAttribute('data-sec') || t.getAttribute('data-section') || t.getAttribute('data-tab') ;
        if (sec) {
          const el = document.getElementById(sec);
          if (el) el.classList.add('active');
        }
        // try to re-render area after switch
        if (typeof render === 'function') try { render(); } catch(e){/*ignore*/ }
        // individual renderers (if exist)
        safeCall('renderPlan'); safeCall('renderForecast'); safeCall('renderKasa'); safeCall('renderAccounts');
      };
      t._otd_cb = cb;
      t.addEventListener('click', cb);
    });
    log('Tabs init ok');
  }

  // --- Make sure hidden sections are not stuck (un-black-screen them) ---
  function unblackSections(){
    // if some sections are 'active' but appear empty, try removing inline hiding
    $$('.section').forEach(sec=>{
      try {
        // ensure display via classes rather than inline style
        sec.style.display = '';
        // if section contains only empty text nodes, leave it; otherwise force visible if has children
        if (sec.children.length > 0) sec.classList.add('active');
      } catch(e){}
    });
    log('unblackSections executed');
  }

  // --- i18n rebind: try to use applyLang already in your file, otherwise fallback ---
  function initLangButtons(){
    const langButtons = $$('.lang button, .lang .btn');
    if (!langButtons.length) return;
    langButtons.forEach(b=>{
      b.removeEventListener('click', b._otd_cb);
      const cb = () => {
        const L = b.dataset.lang || b.getAttribute('data-lang') || b.getAttribute('data-lang-select') || b.textContent.trim().slice(0,2).toLowerCase();
        // call your existing applyLang if present
        if (typeof applyLang === 'function') {
          try { applyLang(L); } catch(e){ log('applyLang failed', e); }
        } else if (typeof window.applyLang === 'function') {
          try { window.applyLang(L); } catch(e) { log('window.applyLang failed', e); }
        } else {
          // minimal fallback: switch [data-i] keys if your M map exists
          if (window.M && window.M[L]) {
            document.querySelectorAll('[data-i]').forEach(el=>{
              const k = el.getAttribute('data-i');
              if (window.M[L][k]) el.textContent = window.M[L][k];
            });
          }
        }
        // visual marker
        langButtons.forEach(x => x.classList.remove('on'));
        b.classList.add('on');
        localStorage.setItem('otd_lang', L);
        // try rerender
        safeCall('render');
      };
      b._otd_cb = cb;
      b.addEventListener('click', cb);
    });
    // initial apply from storage
    const saved = localStorage.getItem('otd_lang') || 'ru';
    const btn = langButtons.find(b=> (b.dataset.lang||b.getAttribute('data-lang')||'').toLowerCase()===saved);
    if (btn) btn._otd_cb();
    log('i18n init done');
  }

  // --- Forecast restore: call existing functions or provide minimal fallback ---
  function ensureForecasts(){
    if (typeof renderForecast === 'function') { try { renderForecast(); log('renderForecast called'); } catch(e){ log('renderForecast err', e); } return; }

    // minimal fallback: compute 7/30 from window.tx or localStorage
    function parseISO(d){ if(!d) return null; try { const m = d.match(/^(\d{4}-\d{2}-\d{2})/); if(m) return new Date(m[1]); const parts = d.split(/[.\-\/]/); if(parts.length>=3){ if(parts[2].length===2) parts[2] = '20'+parts[2]; return new Date(parts[2]+'-'+parts[1]+'-'+parts[0]); } return new Date(d); } catch(e){return null;} }
    const allTx = (window.tx && window.tx.slice()) || (() => { try { return JSON.parse(localStorage.getItem('tx_manual_import')||'[]'); } catch(e){ return []; } })();
    const now = new Date();
    const sumDays = (days) => {
      const cutoff = new Date(now.getTime() + days*86400000);
      return allTx.reduce((s, r) => {
        const date = parseISO(r['Data księgowania'] || r['Дата'] || r['date'] || r['Date']);
        if (!date) return s;
        if (date <= cutoff) return s + Math.abs(Number((r['Kwota']||r['Kwота']||r['amount']||0)));
        return s;
      }, 0);
    };
    const s7 = sumDays(7), s30 = sumDays(30);
    if ( $('#forecastBars') ) {
      // simple text
      $('#forecastBars').innerHTML = '<div class="muted">7d forecast (sum amounts): ' + s7.toFixed(2) + ' PLN</div>';
    }
    if ( $('#forecast30Table') ) {
      $('#forecast30Table').innerHTML = '<div class="muted">30d forecast (sum amounts): ' + s30.toFixed(2) + ' PLN</div>';
    }
    if ($('#forecast7')) $('#forecast7').textContent = isFinite(s7) ? s7.toFixed(2) : '—';
    if ($('#forecast30')) $('#forecast30').textContent = isFinite(s30) ? s30.toFixed(2) : '—';
    log('fallback forecast set');
  }

  // --- Stripe restore: client-side starter for /create-checkout-session ---
  function initStripeButtons(){
    const btnIds = ['pay99','payNow','payAfterDemo','payNowBtn','payNowBtn2'];
    const btns = btnIds.map(id=>document.getElementById(id)).filter(Boolean);
    // also catch generic buttons with text 'Оплатить' or pay-btn class
    btns.push(...$$('button.pay-btn, button.btn.pay, button.pay, .pay-btn').filter(Boolean));
    const unique = Array.from(new Set(btns));

    if (!unique.length) { log('No stripe buttons found to bind'); return; }

    unique.forEach(b=>{
      b.removeEventListener('click', b._otd_cb);
      const cb = async (e) => {
        e.preventDefault();
        // if there's a stored payment link (Payment Link fallback)
        const fallbackLink = localStorage.getItem('stripe_link') || localStorage.getItem('stripePaymentLink');
        if (fallbackLink) { window.location.href = fallbackLink; return; }

        // try calling server endpoint
        try {
          const resp = await fetch('/create-checkout-session', {
            method: 'POST',
            headers: {'Content-Type':'application/json'},
            credentials: 'include',
            body: JSON.stringify({demo: true})
          });
          if (!resp.ok) {
            const txt = await resp.text().catch(()=>null);
            alert('Ошибка создания сессии: ' + (txt || resp.status));
            return;
          }
          const json = await resp.json().catch(()=>null);
          if (json && json.url) { window.location.href = json.url; return; }
          if (json && json.session && json.session.url) { window.location.href = json.session.url; return; }
          alert('Сервер вернул неизвестный ответ. Проверь логи сервера.');
        } catch(err){
          console.error('Stripe start error', err);
          alert('Не удалось связаться с сервером /create-checkout-session. Можно временно положить ссылку в localStorage.stripe_link');
        }
      };
      b._otd_cb = cb;
      b.addEventListener('click', cb);
    });
    log('Stripe buttons bound (client-side)');
  }

  // --- Ensure invoice / accounts / kasa renderers are called if present or provide minimal placeholders ---
  function ensureRenderers(){
    // invoices
    if (!has('invoicesList') && has('billTable')) {
      log('invoicesList not found, using billTable as invoices view');
    }
    if (typeof renderInvoices === 'function') {
      try { renderInvoices(); log('renderInvoices called'); } catch(e){ log('renderInvoices fail', e); }
    } else if (typeof render === 'function') {
      // render() likely renders bills/invoices already
      try { render(); log('render() called as fallback'); } catch(e){ log('render() failed', e); }
    } else {
      // minimal: if bills exist, show count in invoicesList
      const invList = document.getElementById('invoicesList') || document.getElementById('billList') || null;
      if (invList) {
        const bills = (window.bills) || (()=>{ try { return JSON.parse(localStorage.getItem('bills_manual_import')||'[]'); } catch(e){return[];} })();
        invList.innerHTML = '<div class="muted">Invoices: ' + bills.length + '</div>';
      }
    }

    // accountsList
    if (typeof renderAccounts === 'function') {
      try { renderAccounts(); log('renderAccounts called'); } catch(e){ log('renderAccounts fail', e); }
    } else {
      const accList = document.getElementById('accountsList') || document.getElementById('autoAcc') || null;
      if (accList) {
        const accMeta = (function(){ try { return JSON.parse(localStorage.getItem('accMeta')||'{}'); } catch(e){ return {}; } })();
        let html = '<div class="muted">Accounts:</div><ul>';
        Object.keys(accMeta).forEach(k => html += `<li>${k} — ${accMeta[k].currency||'PLN'} / ${ (accMeta[k].start||0) }</li>`);
        html += '</ul>';
        accList.innerHTML = html;
      }
    }

    // kasa (cash)
    if (typeof renderKasa === 'function') {
      try { renderKasa(); log('renderKasa called'); } catch(e){ log('renderKasa fail', e); }
    } else {
      const cd = document.getElementById('cashDetails') || document.getElementById('kasaTable') || null;
      if (cd) {
        const kasa = (function(){ try { return JSON.parse(localStorage.getItem('kasa')||'[]'); } catch(e){ return []; } })();
        cd.innerHTML = '<div class="muted">Касса операций: ' + kasa.length + '</div>';
      }
    }
  }

  // --- Run init sequence safely ---
  function initAll(){
    try { initTabs(); } catch(e){ log('initTabs err', e); }
    try { unblackSections(); } catch(e){ log('unblackSections err', e); }
    try { initLangButtons(); } catch(e){ log('initLangButtons err', e); }
    try { ensureForecasts(); } catch(e){ log('ensureForecasts err', e); }
    try { initStripeButtons(); } catch(e){ log('initStripeButtons err', e); }
    try { ensureRenderers(); } catch(e){ log('ensureRenderers err', e); }
    // final attempt to call your main render if exists
    safeCall('render');
    safeCall('renderPlan');
    safeCall('renderKasa');
    safeCall('renderAccounts');
    safeCall('renderForecast');
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', initAll);
  else initAll();

  // helpful small debug helper to call from console: OTD_PATCH.report()
  window.OTD_PATCH = {
    init: initAll,
    report: function(){
      return {
        sections: $$('.section').map(s => ({id:s.id, classes: s.className, children: s.children.length })),
        langButtons: $$('.lang button').map(b=>({text:b.textContent, data: b.dataset})),
        stripeButtons: Array.from(new Set(['pay99','payNow','payAfterDemo','payNowBtn','payNowBtn2'].map(id=>document.getElementById(id)).filter(Boolean))).length
      };
    }
  };
})();
</script>
<!-- ======= END PATCH ======= -->

</body>
</html>

