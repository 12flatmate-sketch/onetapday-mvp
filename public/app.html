<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>OneTapDay – AI Księgowy (MVP)</title>
  <style>
    :root {
      --accent: #35D36B;
      --bg: #0d0f10;
      --card: #15181a;
      --muted: #9aa3a9;
      --text: #e6edf3;
      --danger: #ff7070;
      --warn: #f4d06f;
      --pos: #a8e8c7;
      --neg: #ff8a8a;
    }
    html, body { background: var(--bg); color: var(--text); font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; }
    .wrap { max-width: 1240px; margin: 0 auto; padding: 12px 16px 48px; }
    .top { display: flex; gap: 12px; align-items: center; justify-content: space-between; flex-wrap: wrap; }
    .top .brand { font-weight: 700; }
    .tabs { display: flex; gap: 6px; flex-wrap: wrap; }
    .tab {
      padding: 8px 12px;
      border-radius: 10px;
      background: #0f1214;
      border: 1px solid #20262b;
      color: #cfe6d7;
      cursor: pointer;
      font-weight: 600;
    }
    .tab.active { background: var(--accent); color: #08110b; border-color: #49e084; }
    .section { display: none; margin-top: 14px; }
    .section.active { display: block; }
    .cards { display: grid; grid-template-columns: repeat(4, minmax(220px, 1fr)); gap: 12px; }
    .card { background: var(--card); border: 1px solid #22282c; border-radius: 12px; padding: 14px; }
    .muted { color: var(--muted); font-size: 13px; }
    .kpi { font-size: 34px; font-weight: 800; margin: 2px 0 0; }
    .btn {
      appearance: none;
      border: 0;
      border-radius: 10px;
      background: var(--accent);
      color: #08110b;
      padding: 10px 14px;
      font-weight: 700;
      cursor: pointer;
    }
    .btn.secondary { background: #20262b; color: #fff; border: 1px solid #2a3136; }
    .btn.ghost { background: transparent; color: #e6edf3; border: 1px dashed #2a3136; }
    .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    table { width: 100%; border-collapse: collapse; margin-top: 8px; }
    th, td { border-bottom: 1px solid #242b30; padding: 8px 6px; font-size: 13px; text-align: left; vertical-align: top; }
    th { color: #9aa3a9; font-weight: 600; }
    .pill {
      display: inline-block;
      padding: 3px 9px;
      border-radius: 999px;
      background: #0f1214;
      border: 1px solid #20262b;
      color: #9aa3a9;
      font-size: 12px;
    }
    .badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 11px;
    }
    .due { background: #2a1f1f; color: #ffb3b3; border: 1px solid #4d3030; }
    .overdue { background: #381f1f; color: #ff8a8a; border: 1px solid #5c2a2a; }
    .cand { background: #23221a; color: #e3e0b0; border: 1px solid #49452c; }
    .ai { background: #1a2320; color: #a8e8c7; border: 1px solid #274b32; }
    .barwrap { display: grid; grid-template-columns: repeat(7, 1fr); gap: 6px; margin-top: 8px; }
    .bar { background: #0f1214; border: 1px solid #20262b; border-radius: 8px; padding: 6px; text-align: center; }
    .bar .h { height: 36px; background: #203026; border: 1px solid #2e4635; border-radius: 6px; margin: 4px 0; }
    .bar.neg .h { background: #3a2222; border-color: #5b3030; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    input[type=file], input[type=text], input[type=number], select {
      background: #0f1214;
      border: 1px solid #20262b;
      border-radius: 8px;
      color: #e6edf3;
      padding: 9px;
    }
    .right { margin-left: auto; }
    .mic {
      border-radius: 50%;
      width: 44px;
      height: 44px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #2a3136;
      background: #0f1214;
      cursor: pointer;
    }
    .mic.on { background: #1d2; color: #08110b; border-color: #3f6; }
    .hint { font-size: 12px; color: #9aa3a9; }
    .thumb { max-height: 60px; border: 1px solid #2a3136; border-radius: 8px; margin-left: 8px; }
    .amt-pos { color: var(--pos); font-weight:700; }
    .amt-neg { color: var(--neg); font-weight:700; }
    @media (max-width: 1080px) {
      .cards { grid-template-columns: 1fr 1fr; }
      .grid2 { grid-template-columns: 1fr; }
    }
    @media print {
      .tabs, .btn, .row input, .toast { display: none !important; }
      body { background: #fff; color: #000; }
      .card { background: #fff; border: 1px solid #999; }
      .wrap { max-width: 1000px; }
    }
    .lang { display: flex; gap: 6px; margin-left: 12px; }
    .lang button {
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid #20262b;
      background: #0f1214;
      color: #9aa3a9;
      font-size: 12px;
      cursor: pointer;
    }
    .lang button.on { background: #274b32; color: #a8e8c7; border-color: #274b32; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div class="brand"><b>OneTapDay — AI Księgowy</b> <span class="pill">MVP</span></div>
      <div class="tabs">
        <div class="tab active" data-sec="pulpit" data-i="tab_dashboard">Пульт</div>
        <div class="tab" data-sec="wyciag" data-i="tab_statement">Wyciąg</div>
        <div class="tab" data-sec="faktury" data-i="tab_invoices">Faktury</div>
        <div class="tab" data-sec="konta" data-i="tab_accounts">Счета</div>
        <div class="tab" data-sec="kasa" data-i="tab_cash">Kasa (нал)</div>
        <div class="tab" data-sec="ustawienia" data-i="tab_settings">Настройки</div>
        <div class="lang" id="langBarMain">
          <button data-lang="ru" class="on">RU</button>
          <button data-lang="en">EN</button>
          <button data-lang="pl">PL</button>
          <button data-lang="uk">UK</button>
        </div>
      </div>
    </div>

    <!-- Dashboard Section -->
    <div id="pulpit" class="section active">
      <div class="cards">
        <div class="card">
          <div class="muted" data-i="kpi_due_today">К оплате сегодня</div>
          <div id="kpiDue" class="kpi">0</div>
        </div>
        <div class="card">
          <div class="muted" data-i="kpi_unmatched">Несвязанные транзакции</div>
          <div id="kpiUnmatch" class="kpi">0</div>
        </div>
        <div class="card">
          <div class="muted" data-i="kpi_banks">Банки в расчёте</div>
          <div id="kpiBank" class="kpi">0</div>
        </div>
        <div class="card">
          <div class="muted" data-i="kpi_cash">Касса (нал)</div>
          <div id="kpiCash" class="kpi">0</div>
        </div>
        <div class="card">
          <div class="muted" data-i="kpi_total">Доступно всего</div>
          <div id="kpiAvail" class="kpi">0</div>
        </div>
        <div class="card">
          <div class="muted" data-i="kpi_gap_today">Разрыв кассы сегодня</div>
          <div id="kpiGap" class="kpi">0</div>
        </div>
      </div>
      <div class="row" style="margin: 10px 0;">
        <button id="syncNow" class="btn" data-i="btn_sync">Синхронизация</button>
        <button id="runAI" class="btn secondary" data-i="btn_ai_match">ИИ-сверка</button>
        <button id="acceptSafe" class="btn secondary" data-i="btn_accept_safe">Принять безопасные пары</button>
        <button id="exportPDF" class="btn secondary" data-i="btn_pdf">PDF отчёт</button>
        <span id="lastSync" class="pill">Синхронизация: —</span>
        <span class="right pill" id="modeCash">Режим: авто</span>
      </div>

      <div class="grid2">
        <div class="card">
          <div style="font-weight: 700;" data-i="minpay_title">Минимальный платёж (штраф-стоп)</div>
          <div id="minPayBox" class="muted">—</div>
          <div class="row" style="margin-top: 6px;">
            <button id="applyMinPay" class="btn secondary" data-i="btn_apply_minpay">Отметить как оплачено</button>
          </div>
        </div>
        <div class="card">
          <div style="font-weight: 700;" data-i="forecast_7d">Прогноз 7 дней</div>
          <div class="muted" data-i="forecast7d_note">Считает PLN-счета из wyciąg (включённые) + кассу.</div>
          <div id="forecastBars" class="barwrap"></div>
          <div id="forecastMeta" class="muted" style="margin-top: 6px;">—</div>
        </div>
      </div>

      <div class="grid2">
        <div class="card">
          <div style="font-weight: 700;" data-i="forecast_30d">Прогноз 30 дней</div>
          <div class="muted" data-i="forecast30_note">Автопрогноз по wyciąg + кассе на 30 дней.</div>
          <div id="forecast30Table"></div>
        </div>
        <div class="card">
          <div style="font-weight: 700;" data-i="month_summary_title">Итоги месяца</div>
          <div id="monthSummary" class="muted">—</div>
        </div>
      </div>

      <div class="card" style="margin-top: 14px;">
        <div class="row">
          <div style="font-weight: 700;" data-i="plan_title">План платежей под кассу</div>
          <div class="right"> 
            <span data-i="filter_label">Фильтр:</span>
            <select id="planFilter">
              <option value="today" data-i="filter_today">Сегодня</option>
              <option value="7d" data-i="filter_7d" selected>7 дней</option>
              <option value="all" data-i="filter_all">Все</option>
            </select>
          </div>
          <label style="margin-left: 10px;">
            <input type="checkbox" id="excludeBlacklist" /> <span data-i="exclude_blacklist">Исключать blacklist</span>
          </label>
        </div>
        <div class="row" style="margin: 8px 0;">
          <button id="makePlan" class="btn secondary" data-i="btn_make_plan">Сформировать</button>
          <button id="applyPlan" class="btn secondary" data-i="btn_apply_plan">Применить</button>
          <span id="planMeta" class="pill">—</span>
        </div>
        <table id="planTable">
          <thead>
            <tr>
              <th>#</th>
              <th data-i="plan_th_invoice">Фактура</th>
              <th data-i="plan_th_supplier">Поставщик</th>
              <th data-i="plan_th_due">Срок</th>
              <th data-i="plan_th_amount">Сумма</th>
              <th data-i="plan_th_reason">Причина</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>

    <!-- Bank Statement Section (Wyciąg) -->
    <div id="wyciag" class="section">
      <div class="row">
        <label class="btn ghost">
          <input id="txFile" type="file" accept=".csv" style="display: none;" />
          <span data-i="upload_statement">Загрузить выписку (CSV)</span>
        </label>

        <label class="btn ghost">
          <input id="txImage" type="file" accept="image/*" multiple style="display: none;" />
          <span>Загрузить скрин выписки (галерея)</span>
        </label>

        <img id="txLastThumb" class="thumb" style="display: none;" />

        <input id="txUrl" type="text" placeholder="URL CSV wyciąga" />
        <button id="saveTxUrl" class="btn secondary" data-i="save_url">Сохранить URL</button>
        <span class="muted">
          Колонки: Data księgowania, ID transakcji, ID konta (или IBAN), Kontrahent, Tytuł/Opis, Kwota(±), Waluta, Status транзакции, Saldo po operacji?
        </span>
      </div>
      <table id="txTable">
        <thead>
          <tr>
            <th data-i="th_date">Дата</th>
            <th data-i="th_account">Счёт</th>
            <th data-i="th_counterparty">Контрагент</th>
            <th data-i="th_desc">Описание</th>
            <th data-i="th_amount">Сумма</th>
            <th data-i="th_currency">Валюта</th>
            <th data-i="th_status">Статус</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <!-- note: оставшиеся секции (faktury, konta, kasa, ustawienia) должны быть вставлены полностью -->
    <!-- если вы их опустили в превью — убедитесь, что в финальном файле они есть, иначе части кода ниже будут проверять на существование элементов -->
  </div>

  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <script>
    // безопасный селектор
    const $id = (id) => document.getElementById(id);

    // Redirect to portal if not logged in (kept intentionally inert for local testing)
    if (!localStorage.getItem("otd_user")) {
      // тестовый режим — не редиректим.
    }

    // i18n map (full RU/EN/PL/UK)
    const M = {
  ru: {
    tab_dashboard: "Пульт", tab_statement: "Выписка", tab_invoices: "Фактуры", tab_accounts: "Счета", tab_cash: "Касса", tab_settings: "Настройки",
    kpi_due_today: "К оплате сегодня", kpi_unmatched: "Несвязанные транзакции", kpi_banks: "Банки в расчёте", kpi_cash: "Касса (нал)", kpi_total: "Доступно всего", kpi_gap_today: "Разрыв кассы сегодня",
    btn_sync: "Синхронизация", btn_ai_match: "ИИ-сверка", btn_accept_safe: "Принять безопасные пары", btn_pdf: "PDF отчёт",
    minpay_title: "Минимальный платёж (штраф-стоп)", btn_apply_minpay: "Отметить как оплачено",
    forecast_7d: "Прогноз 7 дней", forecast7d_note: "Считает PLN-счета из wyciąg (включённые) + кассу.",
    forecast_30d: "Прогноз 30 дней", forecast30_note: "Автопрогноз по wyciąg + кассе на 30 дней.",
    month_summary_title: "Итоги месяца",
    plan_title: "План платежей под кассу", filter_label: "Фильтр:", filter_today: "Сегодня", filter_7d: "7 дней", filter_all: "Все", exclude_blacklist: "Исключать blacklist",
    btn_make_plan: "Сформировать", btn_apply_plan: "Применить",
    plan_th_invoice: "Фактура", plan_th_supplier: "Поставщик", plan_th_due: "Срок", plan_th_amount: "Сумма", plan_th_reason: "Причина",
    upload_statement: "Загрузить выписку (CSV)", save_url: "Сохранить URL",
    th_date: "Дата", th_account: "Счёт", th_counterparty: "Контрагент", th_desc: "Описание", th_amount: "Сумма", th_currency: "Валюта", th_status: "Статус",
    upload_invoices: "Загрузить счета (CSV)", only_overdue: "Только просроченные", show_label: "Показать:",
    inv_th_due: "Срок", inv_th_number: "№", inv_th_supplier: "Поставщик", inv_th_amount: "Сумма", inv_th_currency: "Валюта", inv_th_status: "Статус", inv_th_candidate: "Кандидат", inv_th_score: "Score", inv_th_action: "Действие",
    auto_accounts_title: "Счета из выписки (авто)",
    auto_accounts_desc: "Мы сами собираем счета по полям «ID konta» или «IBAN» из выписки. Включай в расчёт, редактируй стартовый баланс, меняй тип.",
    acc_th_account: "Счёт", acc_th_type: "Тип", acc_th_currency: "Валюта", acc_th_balance_calc: "Баланс (расчёт)", acc_th_start_balance: "Стартовый баланс", acc_th_include: "В расчёт плана",
    btn_add_in: "+ Приём", btn_add_out: "− Выдача", btn_close_shift: "Закрыть смену", btn_scan_receipt: "Сканировать чек (фото)",
    speech_lang: "Язык распознавания:", btn_test_voice: "Тест команд",
    cash_th_date: "Дата", cash_th_type: "Тип", cash_th_amount: "Сумма", cash_th_source: "Источник", cash_th_comment: "Комментарий",
    pilot_subscription_title: "Подписка пилота",
    btn_mark_paid: "Отметить оплату", btn_start_pilot: "Запустить пилот (2 мес.)", btn_activate_discount: "Включить −50% на 12 мес.", btn_reset_pilot: "Сброс",
    start_label: "Начало:", end_label: "Окончание:", discount_label: "Скидка активна до:",
    calc_mode: "Режим расчёта доступных средств", auto_mode_label: "Авто: из счетов wyciąg (включённые) + касса",
    parameters: "Параметры",
    param_cash: "Доступная касса сегодня (ручной PLN):", param_penalty: "Пеня, %/день:", param_interval: "Интервал синха, мин:",
    btn_save_settings: "Сохранить", btn_export_settings: "Экспорт настроек", btn_import_settings: "Импорт настроек",
    auto_mode_explain: "Режим «Авто»: считаем доступные деньги из всех включённых счетов, собранных из wyciąg (или с заданным стартовым балансом), + баланс кассы. Ручной режим берёт только указанную сумму + кассу."
  },

  en: {
    tab_dashboard: "Dashboard", tab_statement: "Statement", tab_invoices: "Invoices", tab_accounts: "Accounts", tab_cash: "Cash", tab_settings: "Settings",
    kpi_due_today: "Due today", kpi_unmatched: "Unmatched transactions", kpi_banks: "Bank balances", kpi_cash: "Cash (PLN)", kpi_total: "Available total", kpi_gap_today: "Cash gap today",
    btn_sync: "Sync", btn_ai_match: "AI match", btn_accept_safe: "Accept safe matches", btn_pdf: "PDF report",
    minpay_title: "Minimum payment (penalty stop)", btn_apply_minpay: "Mark as paid",
    forecast_7d: "7-day forecast", forecast7d_note: "Calculates PLN accounts from statement (included) + cash.",
    forecast_30d: "30-day forecast", forecast30_note: "Autoforecast from statements + cash for 30 days.",
    month_summary_title: "Month summary",
    plan_title: "Payment plan for cash", filter_label: "Filter:", filter_today: "Today", filter_7d: "7 days", filter_all: "All", exclude_blacklist: "Exclude blacklist",
    btn_make_plan: "Build plan", btn_apply_plan: "Apply plan",
    plan_th_invoice: "Invoice", plan_th_supplier: "Supplier", plan_th_due: "Due", plan_th_amount: "Amount", plan_th_reason: "Reason",
    upload_statement: "Upload statement (CSV)", save_url: "Save URL",
    th_date: "Date", th_account: "Account", th_counterparty: "Counterparty", th_desc: "Description", th_amount: "Amount", th_currency: "Currency", th_status: "Status",
    upload_invoices: "Upload invoices (CSV)", only_overdue: "Only overdue", show_label: "Show:",
    inv_th_due: "Due", inv_th_number: "No", inv_th_supplier: "Supplier", inv_th_amount: "Amount", inv_th_currency: "Currency", inv_th_status: "Status", inv_th_candidate: "Candidate", inv_th_score: "Score", inv_th_action: "Action",
    auto_accounts_title: "Accounts from statement (auto)",
    auto_accounts_desc: "We collect accounts by 'ID konta' or IBAN from the statement. Include in plan, edit start balance, change type.",
    acc_th_account: "Account", acc_th_type: "Type", acc_th_currency: "Currency", acc_th_balance_calc: "Balance (calc)", acc_th_start_balance: "Start balance", acc_th_include: "Include in plan",
    btn_add_in: "+ In", btn_add_out: "− Out", btn_close_shift: "Close shift", btn_scan_receipt: "Scan receipt (photo)",
    speech_lang: "Recognition language:", btn_test_voice: "Test commands",
    cash_th_date: "Date", cash_th_type: "Type", cash_th_amount: "Amount", cash_th_source: "Source", cash_th_comment: "Comment",
    pilot_subscription_title: "Pilot subscription",
    btn_mark_paid: "Mark deposit paid", btn_start_pilot: "Start pilot (2 mo.)", btn_activate_discount: "Activate −50% for 12 mo.", btn_reset_pilot: "Reset",
    start_label: "Start:", end_label: "End:", discount_label: "Discount active until:",
    calc_mode: "Calculation mode for available funds", auto_mode_label: "Auto: from statement accounts (included) + cash",
    parameters: "Parameters",
    param_cash: "Manual available cash today (PLN):", param_penalty: "Penalty, %/day:", param_interval: "Sync interval, min:",
    btn_save_settings: "Save", btn_export_settings: "Export settings", btn_import_settings: "Import settings",
    auto_mode_explain: "Auto mode: sum included accounts from statements (or provided start balances) + cash. Manual mode uses specified cash + cashbox."
  },

  pl: {
    tab_dashboard: "Panel", tab_statement: "Wyciąg", tab_invoices: "Faktury", tab_accounts: "Konta", tab_cash: "Kasa", tab_settings: "Ustawienia",
    kpi_due_today: "Do zapłaty dziś", kpi_unmatched: "Niesparowane transakcje", kpi_banks: "Bilans banków", kpi_cash: "Kasa (PLN)", kpi_total: "Dostępnie razem", kpi_gap_today: "Brak środków dziś",
    btn_sync: "Synchronizuj", btn_ai_match: "Dopasowanie AI", btn_accept_safe: "Akceptuj bezpieczne pary", btn_pdf: "Raport PDF",
    minpay_title: "Minimalna płatność (kara-stop)", btn_apply_minpay: "Oznacz jako opłacone",
    forecast_7d: "Prognoza 7 dni", forecast7d_note: "Liczy PLN-konta z wyciągu (włączone) + kasa.",
    forecast_30d: "Prognoza 30 dni", forecast30_note: "Autoprognoza z wyciągów + kasa na 30 dni.",
    month_summary_title: "Podsumowanie miesiąca",
    plan_title: "Plan płatności pod kasę", filter_label: "Filtr:", filter_today: "Dziś", filter_7d: "7 dni", filter_all: "Wszystko", exclude_blacklist: "Wyklucz blacklistę",
    btn_make_plan: "Utwórz plan", btn_apply_plan: "Zastosuj plan",
    plan_th_invoice: "Faktura", plan_th_supplier: "Dostawca", plan_th_due: "Termin", plan_th_amount: "Kwota", plan_th_reason: "Powód",
    upload_statement: "Załaduj wyciąg (CSV)", save_url: "Zapisz URL",
    th_date: "Data", th_account: "Konto", th_counterparty: "Kontrahent", th_desc: "Opis", th_amount: "Kwota", th_currency: "Waluta", th_status: "Status",
    upload_invoices: "Załaduj faktury (CSV)", only_overdue: "Tylko przeterminowane", show_label: "Pokaż:",
    inv_th_due: "Termin", inv_th_number: "Nr", inv_th_supplier: "Dostawca", inv_th_amount: "Kwota", inv_th_currency: "Waluta", inv_th_status: "Status", inv_th_candidate: "Kandydat", inv_th_score: "Score", inv_th_action: "Akcja",
    auto_accounts_title: "Konta z wyciągu (auto)",
    auto_accounts_desc: "Zbieramy konta z pola 'ID konta' lub IBAN w wyciągu. Włącz do planu, edytuj saldo początkowe, zmień typ.",
    acc_th_account: "Konto", acc_th_type: "Typ", acc_th_currency: "Waluta", acc_th_balance_calc: "Saldo (oblicz)", acc_th_start_balance: "Saldo startowe", acc_th_include: "Uwzględnij w planie",
    btn_add_in: "+ Przyjęcie", btn_add_out: "− Wydanie", btn_close_shift: "Zamknij zmianę", btn_scan_receipt: "Skanuj paragon (foto)",
    speech_lang: "Język rozpoznawania:", btn_test_voice: "Test komend",
    cash_th_date: "Data", cash_th_type: "Typ", cash_th_amount: "Kwota", cash_th_source: "Źródło", cash_th_comment: "Komentarz",
    pilot_subscription_title: "Subskrypcja pilota",
    btn_mark_paid: "Oznacz depozyt jako opłacony", btn_start_pilot: "Uruchom pilota (2 mies.)", btn_activate_discount: "Aktywuj −50% na 12 mies.", btn_reset_pilot: "Reset",
    start_label: "Start:", end_label: "Koniec:", discount_label: "Zniżka ważna do:",
    calc_mode: "Tryb obliczania dostępnych środków", auto_mode_label: "Auto: z kont wyciągu (włączone) + kasa",
    parameters: "Parametry",
    param_cash: "Ręczna dostępna kasa dziś (PLN):", param_penalty: "Kara, %/dzień:", param_interval: "Interval sync, min:",
    btn_save_settings: "Zapisz", btn_export_settings: "Eksportuj ustawienia", btn_import_settings: "Importuj ustawienia",
    auto_mode_explain: "Tryb Auto: sumujemy włączone konta z wyciągów (lub startowe salda) + kasa. Tryb ręczny używa podanej kwoty + kasa."
  },

  uk: {
    tab_dashboard: "Пульт", tab_statement: "Виписка", tab_invoices: "Рахунки", tab_accounts: "Рахунки (банки)", tab_cash: "Каса", tab_settings: "Налаштування",
    kpi_due_today: "До сплати сьогодні", kpi_unmatched: "Непов'язані транзакції", kpi_banks: "Баланс банків", kpi_cash: "Каса (PLN)", kpi_total: "Доступно всього", kpi_gap_today: "Розрив каси сьогодні",
    btn_sync: "Синхронізація", btn_ai_match: "AI-звірка", btn_accept_safe: "Прийняти безпечні пари", btn_pdf: "Звіт PDF",
    minpay_title: "Мінімальний платіж (штраф-стоп)", btn_apply_minpay: "Позначити як сплачене",
    forecast_7d: "Прогноз 7 днів", forecast7d_note: "Рахує PLN-рахунки з wyciąg (включені) + каса.",
    forecast_30d: "Прогноз 30 днів", forecast30_note: "Автопрогноз по wyciąg + касі на 30 днів.",
    month_summary_title: "Підсумки місяця",
    plan_title: "План платежів під касу", filter_label: "Фільтр:", filter_today: "Сьогодні", filter_7d: "7 днів", filter_all: "Всі", exclude_blacklist: "Виключати blacklist",
    btn_make_plan: "Сформувати", btn_apply_plan: "Застосувати",
    plan_th_invoice: "Рахунок", plan_th_supplier: "Постачальник", plan_th_due: "Термін", plan_th_amount: "Сума", plan_th_reason: "Причина",
    upload_statement: "Завантажити виписку (CSV)", save_url: "Зберегти URL",
    th_date: "Дата", th_account: "Рахунок", th_counterparty: "Контрагент", th_desc: "Опис", th_amount: "Сума", th_currency: "Валюта", th_status: "Статус",
    upload_invoices: "Завантажити рахунки (CSV)", only_overdue: "Тільки прострочені", show_label: "Показати:",
    inv_th_due: "Термін", inv_th_number: "№", inv_th_supplier: "Постачальник", inv_th_amount: "Сума", inv_th_currency: "Валюта", inv_th_status: "Статус", inv_th_candidate: "Кандидат", inv_th_score: "Score", inv_th_action: "Дія",
    auto_accounts_title: "Рахунки з виписки (авто)",
    auto_accounts_desc: "Ми збираємо рахунки по полях 'ID konta' або IBAN з виписки. Включай у план, редагуй стартовий баланс, змінюй тип.",
    acc_th_account: "Рахунок", acc_th_type: "Тип", acc_th_currency: "Валюта", acc_th_balance_calc: "Баланс (обчисл.)", acc_th_start_balance: "Стартовий баланс", acc_th_include: "Включити в план",
    btn_add_in: "+ Прихід", btn_add_out: "− Видаток", btn_close_shift: "Закрити зміну", btn_scan_receipt: "Сканувати чек (фото)",
    speech_lang: "Мова розпізнавання:", btn_test_voice: "Тест команд",
    cash_th_date: "Дата", cash_th_type: "Тип", cash_th_amount: "Сума", cash_th_source: "Джерело", cash_th_comment: "Коментар",
    pilot_subscription_title: "Підписка пілота",
    btn_mark_paid: "Позначити депозит оплаченим", btn_start_pilot: "Запустити пілот (2 міс.)", btn_activate_discount: "Активувати −50% на 12 міс.", btn_reset_pilot: "Скинути",
    start_label: "Початок:", end_label: "Кінець:", discount_label: "Знижка активна до:",
    calc_mode: "Режим розрахунку доступних коштів", auto_mode_label: "Авто: з рахунків виписки (включені) + каса",
    parameters: "Параметри",
    param_cash: "Доступна каса сьогодні (ручний PLN):", param_penalty: "Пеня, %/день:", param_interval: "Інтервал синхр., хв:",
    btn_save_settings: "Зберегти", btn_export_settings: "Експорт налаштувань", btn_import_settings: "Імпорт налаштувань",
    auto_mode_explain: "Режим «Авто»: рахуємо доступні гроші з усіх включених рахунків, зібраних з wyciąg (або заданого стартового балансу), + баланс каси. Ручний режим бере тільки вказану суму + касу."
  }
};
    function applyLang(lang) {
      const dict = (M[lang] || M.ru);
      document.querySelectorAll('[data-i]').forEach(el => {
        const k = el.getAttribute('data-i');
        if (dict[k]) el.textContent = dict[k];
      });
      document.querySelectorAll('#langBarMain button').forEach(btn=>btn.classList.toggle('on', btn.dataset.lang === lang));
      localStorage.setItem('otd_lang', lang);
    }

    // helpers
    const asNum = v => {
      if (v == null) return 0;
      let s = String(v).trim();
      if (!s) return 0;
      s = s.replace(/\u00A0/g,'').replace(/\s/g, '').replace(/,/g, '.');
      s = s.replace(/[^\d\.\-]/g, '');
      const n = Number(s);
      return isNaN(n) ? 0 : n;
    };
    const today = () => new Date().toISOString().slice(0, 10);

    // robust CSV split
    function smartSplit(line, del) {
      let out = [], cur = "", q = false;
      for (let i = 0; i < line.length; i++) {
        const ch = line[i];
        if (ch === '"') { q = !q; continue; }
        if (ch === del && !q) { out.push(cur); cur = ""; }
        else { cur += ch; }
      }
      out.push(cur);
      return out;
    }
    function parseCSV(text) {
      if (!text) return [];
      // strip BOM
      text = text.replace(/^\uFEFF/, '').replace(/\r/g, "");
      const lines = text.split("\n").filter(l => l.trim());
      if (!lines.length) return [];
      const sep = (lines[0].split(";").length > lines[0].split(",").length) ? ";" : ",";
      const head = smartSplit(lines.shift(), sep).map(h => h.trim());
      return lines.map(line => {
        const cells = smartSplit(line, sep);
        const obj = {};
        head.forEach((h, i) => {
          let v = (cells[i] || "").trim();
          v = v.replace(/\u00A0/g,' ').trim();
          obj[h] = v;
        });
        return obj;
      });
    }

    // normalize date helpers
    function toISO(d) {
      if (!d) return "";
      const s = String(d).trim();
      let m = s.match(/^(\d{4})-(\d{2})-(\d{2})/);
      if (m) return m[0];
      m = s.match(/^(\d{1,2})[.\-/](\d{1,2})[.\-/](\d{2,4})$/);
      if (m) {
        const dd = m[1].padStart(2, "0"),
              mm = m[2].padStart(2, "0"),
              yy = m[3].length === 2 ? ("20" + m[3]) : m[3];
        return yy + "-" + mm + "-" + dd;
      }
      return "";
    }

    // DOM ready
    document.addEventListener('DOMContentLoaded', () => {
      applyLang(localStorage.getItem('otd_lang') || 'ru');

      document.querySelectorAll('#langBarMain button').forEach(b => b.addEventListener('click', ()=>applyLang(b.dataset.lang)));
      document.querySelectorAll('.tabs .tab').forEach(t => t.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(x => x.classList.remove('active'));
        document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
        t.classList.add('active');
        const sec = t.dataset.sec;
        const el = sec ? document.getElementById(sec) : null;
        if (el) el.classList.add('active');
        if (typeof render === 'function') try { render(); } catch(e){/*ignore*/ }
      }));

      // init minimal state
      window.tx = window.tx || [];
      window.bills = window.bills || [];
      window.kasa = window.kasa || [];
    });

    // amount formatting
    function fmtAmountRaw(raw) {
      const n = asNum(raw);
      if (!Number.isFinite(n)) return '<span>—</span>';
      const sign = n < 0 ? '-' : '+';
      const cls = n < 0 ? 'amt-neg' : 'amt-pos';
      const abs = Math.abs(n).toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, " ");
      return `<span class="${cls}">${sign} ${abs}</span>`;
    }

    // --- Core app logic ---
  </script>

  <script>
  (function(){
    // local model
    let tx = [];
    let bills = [];
    let kasa = [];
    let accMeta = {};

    // infer accounts from tx rows
    function inferAccounts() {
      const map = {};
      tx.forEach(r => {
        const id = r["ID konta"] || r["IBAN"] || "UNKNOWN";
        const cur = (r["Waluta"] || r["currency"] || "PLN").toUpperCase();
        if (!map[id]) {
          map[id] = { id, name: String(id).slice(0, 12), currency: cur, include: true, type: "Biznes", start: 0 };
        }
      });
      try {
        const saved = JSON.parse(localStorage.getItem("accMeta") || "{}");
        Object.keys(map).forEach(id => {
          if (saved[id]) map[id] = Object.assign(map[id], saved[id]);
        });
      } catch(e){}
      accMeta = map;
      renderAccounts();
    }

    function computeAccountBalance(accId) {
      const rows = tx.filter(r => (r["ID konta"] || r["IBAN"] || "UNKNOWN") === accId);
      const withSaldo = rows.filter(r => r["Saldo po operacji"]);
      if (withSaldo.length) {
        const last = withSaldo[withSaldo.length - 1];
        return asNum(last["Saldo po operacji"]);
      }
      const start = Number((accMeta[accId] || {}).start || 0);
      const sum = rows.reduce((s, r) => s + asNum(r["Kwota"] || r["Kwота"] || r.amount || 0), 0);
      return start + sum;
    }

    function rate(cur) {
      cur = String(cur || "PLN").toUpperCase();
      if (cur === "PLN") return 1;
      if (cur === "EUR") return asNum(localStorage.getItem("rateEUR") || 4.3);
      if (cur === "USD") return asNum(localStorage.getItem("rateUSD") || 3.95);
      return 1;
    }
    function bankAvailablePLN() {
      let sum = 0;
      Object.values(accMeta).filter(a => a.include).forEach(a => {
        const bal = computeAccountBalance(a.id);
        sum += bal * rate(a.currency);
      });
      return sum;
    }
    function kasaBalance() {
      let bal = 0;
      kasa.forEach(k => {
        if (k.type === "przyjęcie") bal += k.amount;
        if (k.type === "wydanie") bal -= k.amount;
        if (k.type === "zamknięcie") bal = k.amount;
      });
      return bal;
    }
    function availableTotal() {
      const auto = localStorage.getItem("autoCash") === "1";
      const manual = asNum(localStorage.getItem("cashPLN") || 0);
      const kas = kasaBalance();
      return auto ? (bankAvailablePLN() + kas) : (manual + kas);
    }

    // scoring helpers
    function normName(s) {
      s = (s || "").toString().toLowerCase().replace(/[.,]/g, " ").replace(/\s+/g, " ").trim();
      const stop = ["sp z oo", "sp. z o.o.", "spolka", "spółka", "sa", "s.a", "ooo"];
      stop.forEach(t => s = s.replace(t, ""));
      return s.trim();
    }
    function nameSimilar(a, b) {
      a = normName(a); b = normName(b);
      if (!a || !b) return 0;
      if (a === b) return 1;
      if (a.includes(b) || b.includes(a)) return 0.8;
      return 0;
    }
    function scoreMatch(bill, tr) {
      let score = 0;
      const bAmt = asNum(bill["Kwota do zapłaty"] || bill["Kwата до заплаты"] || bill["Kwota"] || bill["Kwата"] || 0);
      const tAmt = Math.abs(asNum(tr["Kwota"] || tr["Kwота"] || tr.amount || 0));
      const bCur = String(bill["Waluta"] || "").toUpperCase();
      const tCur = String(tr["Waluta"] || "").toUpperCase();
      if (bAmt > 0 && tAmt > 0 && Math.abs(bAmt - tAmt) < 0.01 && (bCur === tCur || !bCur || !tCur)) score += 60;
      const inv = String(bill["Numer faktury"] || bill["Numer фактуры"] || "").toLowerCase();
      const desc = String(tr["Tytuł/Opis"] || tr["Opis"] || tr["Tytuł"] || "").toLowerCase();
      if (inv && desc.includes(inv)) score += 25;
      if (nameSimilar(bill["Dostawca"] || bill["Supplier"], tr["Kontrahent"] || tr["Counterparty"] || "") >= 0.8) score += 10;
      if (asNum(tr["Kwota"] || tr.amount) < 0) score += 5;
      return { score: Math.min(100, score) };
    }

    function runAI() {
      bills.forEach(b => {
        const status = String(b["Status faktury"] || b["Status faktury"] || b["Status фактуры"] || "").toLowerCase();
        if (status.includes("opłacone") || status.includes("оплачено") || status.includes("paid")) return;
        let best = null;
        tx.forEach(t => {
          if (String(t["Status transakcji"] || t["status"] || "").toLowerCase() === "sparowane") return;
          if (asNum(t["Kwota"] || t.amount) >= 0) return; // expect outgoing negative for payments
          const s = scoreMatch(b, t);
          if (!best || s.score > best.s) best = { t, s: s.score };
        });
        if (best && best.s >= 85) {
          best.t["Status transakcji"] = "Sparowane";
          best.t["Powiązana faktura (ID)"] = b["Numer faktury"] || b["Numer фактуры"];
          b["Status faktury"] = "Opłacone";
          b["Data płatności"] = today();
        } else if (best && best.s >= 55) {
          b["Kandydat (AI)"] = best.t["ID transakcji"];
          b["AI score"] = best.s;
        } else {
          b["Kandydat (AI)"] = "";
          b["AI score"] = "";
        }
      });
      render();
    }
    function acceptSafe() {
      bills
        .filter(b => Number(b["AI score"] || 0) >= 85)
        .forEach(b => {
          const t = tx.find(t => t["ID transakcji"] === b["Kandydat (AI)"]);
          if (!t) return;
          t["Status transakcji"] = "Sparowane";
          t["Powiązana faktura (ID)"] = b["Numer faktury"] || b["Numer фактуры"];
          b["Status faktury"] = "Opłacone";
          b["Data płatności"] = today();
          b["Kandydat (AI)"] = b["AI score"] = "";
        });
      render();
    }

    // normalize keys for an imported row
    function normalizeRowKeys(r) {
      const kw = (r["Kwota"] || r["Kwота"] || r["amount"] || r.amount || "");
      const kwNum = asNum(kw);
      return {
        "Data księgowania": r["Data księgowania"] || r.date || r["Дата"] || today(),
        "ID transakcji": r["ID transakcji"] || r.id || ("IMG-" + Date.now() + "-" + Math.floor(Math.random()*9999)),
        "ID konta": r["ID konta"] || r.account || r["IBAN"] || "UNKNOWN",
        "Kontrahent": r["Kontrahent"] || r.counterparty || r["Контрагент"] || "",
        "Tytuł/Opis": r["Tytuł/Opis"] || r.desc || r["Описание"] || (r.title || ""),
        "Kwota": (Number.isFinite(kwNum) ? kwNum.toFixed(2) : (typeof kw === 'number' ? String(kw) : (kw || ""))),
        "Waluta": r["Waluta"] || r.currency || "PLN",
        "Status transakcji": r["Status transakcji"] || r.status || "imported",
        "Saldo po operacji": r["Saldo po operacji"] || r.saldo || ""
      };
    }

    // OCR function (kept robust). It pushes normalized rows into tx or bills.
    async function processImageFileFor(targetArrayName, file) {
      if (!file) return;
      const imgURL = URL.createObjectURL(file);
      const thumbId = (targetArrayName === 'tx') ? 'txLastThumb' : ((targetArrayName === 'bills') ? 'billLastThumb' : null);
      if (thumbId) {
        const thumb = document.getElementById(thumbId);
        if (thumb) { thumb.src = imgURL; thumb.style.display = "inline-block"; }
      }

      function parseAmountToken(tok) {
        if (!tok) return null;
        const curMatch = tok.match(/\b(PLN|zł|zl|zlot|EUR|USD)\b/i);
        const currency = curMatch ? (curMatch[1].toUpperCase().replace('ZŁ','PLN').replace('ZLOT','PLN')) : 'PLN';
        const numMatch = tok.match(/-?\s*\d{1,3}(?:[ \u00A0]\d{3})*(?:[.,]\d{2})|\d+[.,]\d{2}/);
        if (!numMatch) return null;
        let numStr = numMatch[0].replace(/\s/g,'').replace(/\u00A0/g,'').replace(',', '.').replace('−','-');
        const negative = /-/.test(tok) || /^\-/.test(numStr);
        numStr = numStr.replace(/^\-/, '');
        const value = Number(numStr);
        if (isNaN(value)) return null;
        return { value: negative ? -value : value, raw: numMatch[0], currency, negative };
      }
      function detectDateLine(line) {
        line = (line || "").trim();
        if (!line) return null;
        let m = line.match(/(\d{4})[.\-/](\d{2})[.\-/](\d{2})/);
        if (m) return `${m[1]}-${m[2]}-${m[3]}`;
        m = line.match(/(\d{1,2})[.\-/](\d{1,2})[.\-/](\d{2,4})/);
        if (m) {
          const dd = m[1].padStart(2,'0'), mm = m[2].padStart(2,'0');
          let yy = m[3]; if (yy.length === 2) yy = '20' + yy;
          return `${yy}-${mm}-${dd}`;
        }
        return null;
      }

      try {
        const img = await new Promise((res, rej) => {
          const i = new Image();
          i.onload = () => res(i);
          i.onerror = (e) => rej(e);
          i.src = imgURL;
        });

        const maxDim = 2600;
        const scale = Math.min(3, Math.max(1, maxDim / Math.max(img.width, img.height)));
        const w = Math.round(img.width * scale), h = Math.round(img.height * scale);
        const canvas = document.createElement('canvas'); canvas.width = w; canvas.height = h;
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(img, 0, 0, w, h);

        try {
          const id = ctx.getImageData(0,0,w,h);
          const d = id.data;
          let sum = 0, sum2 = 0, cnt = 0;
          for (let i=0;i<d.length;i+=4) {
            const r = d[i], g = d[i+1], b = d[i+2];
            const l = Math.round(0.299*r + 0.587*g + 0.114*b);
            d[i] = d[i+1] = d[i+2] = l;
            sum += l; sum2 += l*l; cnt++;
          }
          ctx.putImageData(id,0,0);
          const mean = sum / Math.max(1, cnt);
          const std = Math.sqrt(Math.max(0, sum2/cnt - mean*mean));
          if (mean < 120) {
            const id2 = ctx.getImageData(0,0,w,h); const d2 = id2.data;
            for (let i=0;i<d2.length;i+=4) { d2[i] = 255 - d2[i]; d2[i+1] = 255-d2[i+1]; d2[i+2] = 255-d2[i+2]; }
            ctx.putImageData(id2,0,0);
          }
          const final = ctx.getImageData(0,0,w,h);
          const df = final.data;
          const thresh = Math.max(120, Math.round(mean - std * 0.1));
          for (let i=0;i<df.length;i+=4) {
            const v = df[i];
            const val = v < thresh ? 0 : 255;
            df[i] = df[i+1] = df[i+2] = val;
          }
          ctx.putImageData(final, 0, 0);
        } catch(err) {
          console.warn('preprocess fail, continue', err);
        }

        const dataUrl = canvas.toDataURL('image/png', 1.0);

        const worker = await Tesseract.createWorker();
        await worker.load();
        // try sensible languages
        try {
          await worker.loadLanguage('pol+eng+rus');
          await worker.initialize('pol+eng+rus');
        } catch(e) {
          try { await worker.loadLanguage('pol+eng'); await worker.initialize('pol+eng'); }
          catch(e2) { try { await worker.loadLanguage('eng'); await worker.initialize('eng'); } catch(e3) { /* fallback */ } }
        }

        const { data: { text } } = await worker.recognize(dataUrl);
        await worker.terminate();

        const cleaned = String(text || "").replace(/\u00A0/g,' ').replace(/\r/g,' ').trim();
        localStorage.setItem('lastOCR', cleaned);

        const lines = cleaned.split('\n').map(l => l.trim()).filter(Boolean);
        const amountREglobal = /-?\s*\d{1,3}(?:[ \u00A0]\d{3})*(?:[.,]\d{2})\s*(PLN|zł|zl|zlot|EUR|USD)?/gi;

        let currentDateIso = null;
        let bufferDesc = [];
        const foundTx = [];

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          const dIso = detectDateLine(line);
          if (dIso) { currentDateIso = dIso; bufferDesc = []; continue; }
          const amounts = [...line.matchAll(amountREglobal)];
          if (amounts && amounts.length) {
            const firstAmtIndex = amounts[0].index || 0;
            let leftPart = line.slice(0, firstAmtIndex).trim();
            let desc = (bufferDesc.length ? bufferDesc.join(' | ') + ' ' : '') + (leftPart ? leftPart : '');
            if (!desc.trim() && i > 0) {
              const prev = lines[i-1].trim();
              if (!detectDateLine(prev) && !prev.match(amountREglobal)) desc = prev;
            }
            for (let j = 0; j < amounts.length; j++) {
              const aRaw = amounts[j][0];
              const parsed = parseAmountToken(aRaw + (amounts[j][1] ? ' ' + amounts[j][1] : ''));
              if (!parsed) continue;
              const leftNearby = line.slice(Math.max(0, (amounts[j].index || 0) - 10), (amounts[j].index || 0) + aRaw.length + 10);
              const outWords = /(wydatek|wydano|wydat|spend|zapłacono|оплачено|płatn|платеж|przelew do|to:|transfer to|paid)/i;
              const inWords = /(wpłata|przychód|przychod|otrzymano|received|przyjęcie|od:|from:|płatn|wpł|przelew od)/i;
              let negative = parsed.value < 0 || /-/.test(aRaw) || outWords.test(leftNearby);
              if (inWords.test(leftNearby)) negative = false;
              const amountVal = negative ? -Math.abs(parsed.value) : Math.abs(parsed.value);

              const txObj = {
                "ID transakcji": "IMG-" + Date.now() + "-" + Math.floor(Math.random()*9999),
                "Data księgowania": currentDateIso || (new Date().toISOString().slice(0,10)),
                "ID konta": "UNKNOWN",
                "Kontrahent": (desc ? desc.slice(0,200) : (lines[i+1] || "").slice(0,200)),
                "Tytuł/Opis": (desc + (amounts.length > 1 ? ` (part ${j+1}/${amounts.length})` : '')).slice(0,400),
                "Kwota": (amountVal).toFixed(2),
                "Kwota_raw": aRaw,
                "Waluta": (parsed.currency || "PLN").toUpperCase(),
                "Status transakcji": "imported"
              };
              foundTx.push(txObj);
            }
            bufferDesc = [];
            continue;
          }
          bufferDesc.push(line);
          if (bufferDesc.length > 4) bufferDesc.shift();
        }

        // fallback: if foundTx not empty commit
        if (foundTx.length) {
          for (const r of foundTx) {
            const normalized = normalizeRowKeys ? normalizeRowKeys(r) : r;
            if (targetArrayName === 'tx') { tx.unshift(normalized); }
            else if (targetArrayName === 'bills') {
              const billRow = {
                "Termin płatności": normalized["Data księgowania"],
                "Numer faktury": "IMG-FV-" + Date.now() + "-" + Math.floor(Math.random()*9999),
                "Dostawca": normalized["Kontrahent"],
                "Kwota do zapłaty": Math.abs(asNum(normalized["Kwota"] || 0)).toFixed(2),
                "Waluta": normalized["Waluta"] || "PLN",
                "Status faktury": "do zapłaty",
                "Kandydat (AI)": "",
                "AI score": ""
              };
              bills.unshift(billRow);
            }
          }
          try { localStorage.setItem("tx_manual_import", JSON.stringify(tx)); } catch(e) {}
          try { localStorage.setItem("bills_manual_import", JSON.stringify(bills)); } catch(e) {}
          inferAccounts();
          render();
          return;
        }

        // final fallback single-row
        const amtMatch = cleaned.replace(",", ".").match(/(-?\d{1,3}(?:[ .]\d{3})*(?:[.,]\d{2})|\d+[.,]\d{2})\s*(PLN|zł|zl|EUR|USD)?/i);
        const amtStr = amtMatch ? amtMatch[1].replace(/\s/g,'').replace(/\./g,'').replace(',', '.') : null;
        let fallbackAmt = amtStr ? Number(amtStr) : null;
        const dateMatch = cleaned.match(/(\d{2}[.\-/]\d{2}[.\-/]\d{2,4})/);
        const baseObj = {
          "ID transakции": "IMG-" + Date.now(),
          "Data księgowania": dateMatch ? toISO(dateMatch[1]) : (currentDateIso || (new Date().toISOString().slice(0,10))),
          "ID konta": "UNKNOWN",
          "Kontrahent": cleaned.split("\n")[0] || "",
          "Tytuł/Opis": ("OCR: " + cleaned.split("\n").slice(0,3).join(" ")).slice(0,400),
          "Kwота": (fallbackAmt != null ? fallbackAmt.toFixed(2) : ""),
          "Waluta": amtMatch && amtMatch[2] ? amtMatch[2].toUpperCase() : "PLN",
          "Status transakcji": "imported"
        };
        const normalized = normalizeRowKeys ? normalizeRowKeys(baseObj) : baseObj;
        if (targetArrayName === 'tx') {
          tx.unshift(normalized);
          try { localStorage.setItem("tx_manual_import", JSON.stringify(tx)); } catch(e){}
          inferAccounts();
          render();
        } else if (targetArrayName === 'bills') {
          bills.unshift({
            "Termin płatności": normalized["Data księgования"],
            "Numer faktуры": "IMG-FV-" + Date.now(),
            "Dostawca": normalized["Kontrahent"],
            "Kwота до заплаты": Math.abs(asNum(normalized["Kwота"] || 0)).toFixed(2),
            "Waluta": normalized["Waluta"] || "PLN",
            "Status фактуры": "do zapłaty",
            "Kandydat (AI)": "",
            "AI score": ""
          });
          try { localStorage.setItem("bills_manual_import", JSON.stringify(bills)); } catch(e){}
          render();
        }

      } catch(err) {
        console.error("OCR error (processImageFileFor):", err);
        try { alert("Не удалось распознать скрин: " + (err && err.message ? err.message : String(err))); } catch(e) {}
      }
    }

    // wire image inputs safely
    document.addEventListener('DOMContentLoaded', () => {
      const txImage = $id('txImage');
      if (txImage) {
        txImage.addEventListener('change', async e => {
          const files = Array.from(e.target.files || []);
          if (!files.length) return;
          const last = $id("lastSync");
          if (last) last.textContent = "Синхронизация: " + new Date().toLocaleString();
          for (const f of files) {
            await processImageFileFor('tx', f);
          }
          e.target.value = '';
        });
      }
      // other optional inputs (only wire if exist)
      const billImage = $id('billImage');
      if (billImage) {
        billImage.addEventListener('change', async e => {
          const files = Array.from(e.target.files || []);
          if (!files.length) return;
          for (const f of files) {
            await processImageFileFor('bills', f);
          }
          e.target.value = '';
        });
      }
    });

    // render helpers
    function renderKasa() {
      const tb = document.querySelector("#kasaTable tbody");
      if (!tb) return;
      tb.innerHTML = "";
      kasa.forEach((k, i) => {
        const tr = document.createElement("tr");
        tr.innerHTML = `<td>${i + 1}</td><td>${k.date}</td><td>${k.type}</td><td>${k.amount.toFixed(2)}</td><td>${k.source || ""}</td><td>${k.comment || ""}</td>`;
        tb.appendChild(tr);
      });
    }

    function renderAccounts() {
      const tb = document.querySelector("#autoAcc tbody");
      if (!tb) return;
      tb.innerHTML = "";
      Object.values(accMeta).forEach(a => {
        const bal = computeAccountBalance(a.id);
        const tr = document.createElement("tr");
        tr.innerHTML = `<td>${a.id}</td>
          <td>
            <select data-id="${a.id}" class="acc-type">
              <option ${a.type === "Biznes" ? "selected" : ""}>Biznes</option>
              <option ${a.type === "Osobisty" ? "selected" : ""}>Osobisty</option>
            </select>
          </td>
          <td>
            <select data-id="${a.id}" class="acc-cur">
              <option ${a.currency === "PLN" ? "selected" : ""}>PLN</option>
              <option ${a.currency === "EUR" ? "selected" : ""}>EUR</option>
              <option ${a.currency === "USD" ? "selected" : ""}>USD</option>
            </select>
          </td>
          <td>${bal.toFixed(2)}</td>
          <td><input type="number" step="0.01" value="${a.start || 0}" class="acc-start" data-id="${a.id}" /></td>
          <td><input type="checkbox" class="acc-include" data-id="${a.id}" ${a.include ? "checked" : ""} /></td>`;
        tb.appendChild(tr);
      });
      // bind events
      tb.querySelectorAll(".acc-type").forEach(el => el.addEventListener("change", e => {
        const id = e.target.dataset.id;
        accMeta[id].type = e.target.value;
        saveAccMeta();
        render();
      }));
      tb.querySelectorAll(".acc-cur").forEach(el => el.addEventListener("change", e => {
        const id = e.target.dataset.id;
        accMeta[id].currency = e.target.value;
        saveAccMeta();
        render();
      }));
      tb.querySelectorAll(".acc-start").forEach(el => el.addEventListener("change", e => {
        const id = e.target.dataset.id;
        accMeta[id].start = asNum(e.target.value);
        saveAccMeta();
        render();
      }));
      tb.querySelectorAll(".acc-include").forEach(el => el.addEventListener("change", e => {
        const id = e.target.dataset.id;
        accMeta[id].include = e.target.checked;
        saveAccMeta();
        render();
      }));
    }
    function saveAccMeta() { try { localStorage.setItem("accMeta", JSON.stringify(accMeta)); } catch(e){} }

    // Kasa CRUD safe
    function loadKasa() {
      try { kasa = JSON.parse(localStorage.getItem("kasa") || "[]"); } catch(e) { kasa = []; }
    }
    function saveKasa() { try { localStorage.setItem("kasa", JSON.stringify(kasa)); } catch(e){} }
    function addKasa(type, amount, comment, source) {
      if (amount == null || isNaN(amount)) return alert("Сумма некорректна");
      kasa.push({ id: Date.now(), date: today(), type, amount: Number(amount), comment: comment || "", source: source || "ручной" });
      saveKasa();
      render();
      renderKasa();
    }

    // plan helpers
    function toDueList(mode) {
      const t = today();
      const excl = $id("excludeBlacklist") ? document.getElementById("excludeBlacklist").checked : false;
      return bills.filter(r => {
        const s = String(r["Status faktury"] || r["Status faktury"] || r["Status факуры"] || r["Status факуры"] || "").toLowerCase();
        if (!["do zapłaty", "przeterminowane", "к оплате", "просрочено", "to pay"].includes(s)) return false;
        const d = toISO(r["Termin płатności"] || r["Termin платности"] || r["Termin платежи"] || r["Termin платежи"]);
        if (!d) return false;
        if (mode === "today") return d === t;
        if (mode === "7d") {
          const dd = new Date(d), tt = new Date(t);
          return (dd - tt) / (1000 * 3600 * 24) <= 7;
        }
        return true;
      }).filter(r => {
        if (String(r["Waluta"] || r["Walута"] || "").toUpperCase() !== "PLN") return false;
        if (excl) {
          const blist = (localStorage.getItem("blacklist") || "").toLowerCase();
          if (blist && r["Dostawca"] && blist.split(",").some(name => r["Dostawca"].toLowerCase().includes(name.trim()))) {
            return false;
          }
        }
        return true;
      });
    }

    function buildPlan() {
      const planFilter = $id("planFilter");
      const mode = planFilter ? planFilter.value : "7d";
      const cand = toDueList(mode).sort((a, b) => {
        const da = new Date(toISO(a["Termin płатności"] || a["Termin платности"] || a["Termin платежи"] || today()));
        const db = new Date(toISO(b["Termin płатności"] || b["Termin платности"] || b["Termin платежи"] || today()));
        const lateA = da < new Date(today());
        const lateB = db < new Date(today());
        if (lateA !== lateB) return lateB - lateA;
        return asNum(b["Kwота до заплаты"] || b["Kwота до заплаты"] || 0) - asNum(a["Kwота до заплаты"] || a["Kwота до заплаты"] || 0);
      });
      let left = availableTotal();
      const plan = [];
      for (const r of cand) {
        const amt = asNum(r["Kwота до заплаты"] || r["Kwота до заплаты"] || r["Kwota do zapłaty"] || r["Kwota do zapłaty"] || 0);
        if (amt <= left) {
          plan.push({
            r,
            amt,
            reason: (toISO(r["Termin płатności"] || r["Termin платности"] || r["Termin платежи"]) < today() ? "просрочка" : "срок")
          });
          left -= amt;
        }
      }
      return { plan, left, avail: availableTotal() };
    }

    function renderPlan() {
      const p = buildPlan();
      const tb = document.getElementById("planTable") ? document.getElementById("planTable").querySelector("tbody") : null;
      if (!tb) return;
      tb.innerHTML = "";
      p.plan.forEach((x, i) => {
        const tr = document.createElement("tr");
        tr.innerHTML = `<td>${i + 1}</td><td>${x.r["Numer faktury"] || x.r["Numer фактуры"] || ""}</td><td>${x.r["Dostawca"] || ""}</td><td>${toISO(x.r["Termin płatności"] || x.r["Termin платности"] || x.r["Termin платежи"])}</td><td>${x.amt.toFixed(2)}</td><td>${x.reason}</td>`;
        tb.appendChild(tr);
      });
      const metaText = p.plan.length 
        ? `Потратим ${(p.avail - p.left).toFixed(2)} из ${p.avail.toFixed(2)} PLN. Останется ${p.left.toFixed(2)} PLN.` 
        : "План пуст или денег нет.";
      const pm = $id("planMeta");
      if (pm) pm.textContent = metaText;
    }

    function computeMinPay() {
      const t = today();
      const pctVal = asNum(localStorage.getItem("penaltyPct") || 0.05);
      const pct = pctVal / 100.0;
      const cand = bills.filter(r => 
        String((r["Waluta"] || r["Walута"] || "").toUpperCase()) === "PLN" &&
        toISO(r["Termin płatności"] || r["Termin платности"] || r["Termin платежи"]) <= t &&
        ["do zapłaty", "przeterminowane", "к оплате", "просрочено"].includes(String(r["Status фактуры"] || r["Status фактуры"] || r["Status фактуры"] || "").toLowerCase())
      ).map(r => ({
        r,
        amt: asNum(r["Kwота до заплаты"] || r["Kwота до заплаты"] || r["Kwота"] || 0),
        risk: asNum(r["Kwота до заплаты"] || r["Kwота до заплаты"] || r["Kwота"] || 0) * pct
      })).sort((a, b) => b.risk - a.risk || b.amt - a.amt);
      return cand[0] || null;
    }
    function renderMinPay() {
      const m = computeMinPay();
      const el = $id("minPayBox");
      if (!el) return;
      if (!m) { el.textContent = "—"; return; }
      el.textContent = `Оплатить ${m.r["Numer faktury"] || m.r["Numer фактуры"]} (${m.r["Dostawca"]}) на ${m.amt.toFixed(2)} PLN. Штраф/день ~ ${m.risk.toFixed(2)} PLN.`;    }

    function renderForecast() {
      const t = new Date(today());
      const list = toDueList("7d").map(r => ({ date: new Date(toISO(r["Termin płатності"] || r["Termin платности"] || r["Termin платежи"])), amt: asNum(r["Kwота до заплаты"] || r["Kwота до заплаты"] || r["Kwота do zapłaty"] || 0) }));
      const days = [...Array(7)].map((_, i) => new Date(t.getTime() + i * 86400000));
      let left = availableTotal();
      const out = days.map(d => ({ d, due: 0, after: 0 }));
      list.forEach(x => {
        const idx = Math.min(6, Math.max(0, Math.floor((x.date - t) / 86400000)));
        out[idx].due += x.amt;
      });
      out.forEach(o => { left -= o.due; o.after = left; });
      const wrap = document.getElementById("forecastBars");
      if (!wrap) return;
      wrap.innerHTML = "";
      out.forEach(o => {
        const div = document.createElement("div");
        div.className = "bar" + (o.after < 0 ? " neg" : "");
        const h = document.createElement("div");
        h.className = "h";
        h.style.height = (Math.min(120, Math.abs(o.after) / 100) * 0.8 + 18) + "px";
        div.innerHTML = "<small>" + o.d.toISOString().slice(5, 10) + "</small>";
        div.appendChild(h);
        const v = document.createElement("div");
        v.textContent = (o.after < 0 ? "-" : "") + Math.abs(o.after).toFixed(0) + " PLN";
        div.appendChild(v);
        wrap.appendChild(div);
      });
      const firstNeg = out.find(x => x.after < 0);
      const meta = $id("forecastMeta");
      if (meta) meta.textContent = firstNeg
        ? `Гэп через ${out.indexOf(firstNeg) + 1} дн.: не хватает ${Math.abs(firstNeg.after).toFixed(2)} PLN.`
        : "На 7 дней хватает кассы.";
    }

    // full render (safe)
    function render() {
      try {
        tx = (JSON.parse(localStorage.getItem("tx_manual_import") || "[]").concat(tx || [])).slice(0, 5000); // avoid uncontrolled growth
      } catch(e){}
      try { bills = (JSON.parse(localStorage.getItem("bills_manual_import") || "[]").concat(bills || [])).slice(0, 5000); } catch(e){}
      try { accMeta = Object.assign({}, JSON.parse(localStorage.getItem("accMeta") || "{}"), accMeta || {}); } catch(e){}

      const dueToday = (bills || []).filter(r => {
        const s = String(r["Status фактуры"] || r["Status фактуры"] || r["Status фактуры"] || r["Status фактуры"] || "").toLowerCase();
        return ["do zapłaty", "przeterminowane", "к оплате", "просрочено"].includes(s) && toISO(r["Termin платності"] || r["Termin платности"] || r["Termin платежи"]) === today();
      }).length;
      const unmatch = (tx || []).filter(r => String(r["Status transakcji"] || r["status"] || "").toLowerCase() !== "sparowane").length;
      const elDue = $id("kpiDue"), elUn = $id("kpiUnmatch"), elBank = $id("kpiBank"), elCash = $id("kpiCash"), elAvail = $id("kpiAvail"), elGap = $id("kpiGap");
      if (elDue) elDue.textContent = dueToday;
      if (elUn) elUn.textContent = unmatch;
      const bankPLN = bankAvailablePLN();
      if (elBank) elBank.textContent = bankPLN.toFixed(2);
      const kas = kasaBalance();
      if (elCash) elCash.textContent = kas.toFixed(2);
      const avail = availableTotal();
      if (elAvail) elAvail.textContent = avail.toFixed(2);

      // compute sumDueToday and gap
      const sumDueToday = (bills || []).filter(r =>
        String((r["Waluta"] || r["Walута"] || "").toUpperCase()) === "PLN" &&
        toISO(r["Termin платності"] || r["Termin платности"] || r["Termin платежи"]) <= today() &&
        ["do zapłaty", "przeterminowane", "к оплате", "просрочено"].includes(String(r["Status фактуры"] || r["Status фактуры"] || r["Status фактуры"] || "").toLowerCase())
      ).reduce((s, r) => s + asNum(r["Kwота до заплаты"] || r["Kwота до заплаты"] || r["Kwота"] || 0), 0);
      if (elGap) elGap.textContent = Math.max(0, sumDueToday - avail).toFixed(2);

      // Transactions table
      const txBody = document.getElementById("txTable") ? document.getElementById("txTable").querySelector("tbody") : null;
      if (txBody) {
        txBody.innerHTML = "";
        (tx || []).forEach(r => {
          const tr = document.createElement("tr");
          const amountHtml = fmtAmountRaw(r["Kwота"] || r["Kwота"] || r["amount"] || r["Kwота_raw"] || 0);
          tr.innerHTML = `<td>${toISO(r["Data księgowania"])}</td>
                          <td>${(r["ID konta"] || r["IBAN"] || "—")}</td>
                          <td>${(r["Kontrahent"] || "")}</td>
                          <td>${(r["Tytuł/Opis"] || r["Opis operacji"] || "")}</td>
                          <td>${amountHtml}</td>
                          <td>${r["Walута"] || r["Waluta"] || ""}</td>
                          <td>${r["Status transakcji"] || ""}</td>`;
          txBody.appendChild(tr);
        });
      }

      // Invoices table (if exists)
      const billTable = document.getElementById("billTable") ? document.getElementById("billTable").querySelector("tbody") : null;
      if (billTable) {
        billTable.innerHTML = "";
        const scopeEl = document.getElementById("billScope");
        const scope = scopeEl ? scopeEl.value : "7d";
        const onlyOverdue = document.getElementById("billOverdueOnly") ? document.getElementById("billOverdueOnly").checked : false;
        (bills || []).forEach(r => {
          const s = String(r["Status фактуры"] || r["Status фактуры"] || r["Status фактуры"] || "").toLowerCase();
          if (!["do zapłaty", "przeterminowane", "к оплате", "просрочено"].includes(s)) return;
          if (onlyOverdue && !(s.includes("przetermin") || s.includes("проср"))) return;
          const d = toISO(r["Termin платности"] || r["Termin платности"] || r["Termin платежи"]);
          if (scope === "today" && d !== today()) return;
          if (scope === "7d") {
            const dd = new Date(d), tt = new Date(today());
            if ((dd - tt) / (1000 * 3600 * 24) > 7) return;
          }
          const cls = (s.includes("przetermin") || s.includes("проср")) ? "overdue" : "due";
          const cand = r["Kandydat (AI)"] || "";
          const score = r["AI score"] || "";
          const tr = document.createElement("tr");
          tr.innerHTML = `<td>${d}</td>
                          <td>${r["Numer фактуры"] || r["Numer фактуры"] || ""}</td>
                          <td>${r["Dostawca"] || ""}</td>
                          <td>${(r["Kwота до заплаты"] || r["Kwота до заплаты"] || "")}</td>
                          <td>${r["Waluta"] || ""}</td>
                          <td><span class="badge ${cls}">${r["Status фактуры"] || r["Status фактуры"] || ""}</span></td>
                          <td>${cand ? ('<span class="badge cand">' + cand + '</span>') : '—'}</td>
                          <td>${score ? ('<span class="badge ai">' + score + '</span>') : '—'}</td>
                          <td>${cand ? ('<button class="btn secondary btn-accept" data-id="' + (r["Numer фактуры"] || r["Numer фактуры"] || "") + '">Принять</button>') : '—'}</td>`;
          billTable.appendChild(tr);
        });
        document.querySelectorAll(".btn-accept").forEach(b =>
          b.addEventListener("click", () => acceptOne(b.getAttribute("data-id")))
        );
      }

      renderMinPay();
      renderForecast();
      renderAccounts();
      renderKasa();
    }

    function acceptOne(id) {
      const b = (bills || []).find(x => (x["Numer фактуры"] || x["Numer фактуры"] || "") === id);
      if (!b) return;
      const t = (tx || []).find(x => (x["ID transakcji"] || "") === (b["Kandydат (AI)"] || ""));
      if (!t) return;
      t["Status transakcji"] = "Sparowane";
      t["Powiązana фактура (ID)"] = b["Numer фактуры"] || b["Numer фактуры"];
      b["Status фактуры"] = "Opłacone";
      b["Data płatności"] = today();
      b["Kandydат (AI)"] = b["AI score"] = "";
      render();
    }

    // event bindings safely (only if elements exist)
    document.addEventListener('DOMContentLoaded', () => {
      const runAIbtn = $id("runAI"); if (runAIbtn) runAIbtn.addEventListener("click", runAI);
      const acceptSafeBtn = $id("acceptSafe"); if (acceptSafeBtn) acceptSafeBtn.addEventListener("click", acceptSafe);
      const makePlanBtn = $id("makePlan"); if (makePlanBtn) makePlanBtn.addEventListener("click", renderPlan);
      const applyPlanBtn = $id("applyPlan"); if (applyPlanBtn) applyPlanBtn.addEventListener("click", applyPlan);
      const applyMinPayBtn = $id("applyMinPay"); if (applyMinPayBtn) applyMinPayBtn.addEventListener("click", () => {
        const m = computeMinPay();
        if (!m) return alert("Нет кандидатов");
        m.r["Status фактуры"] = "Opłacone";
        m.r["Data płatności"] = today();
        render();
      });

      const planFilter = $id("planFilter"); if (planFilter) planFilter.addEventListener("change", renderPlan);
      const billScope = $id("billScope"); if (billScope) billScope.addEventListener("change", render);
      const excludeBlacklist = $id("excludeBlacklist"); if (excludeBlacklist) excludeBlacklist.addEventListener("change", () => { renderPlan(); render(); });
      const billOverdueOnly = $id("billOverdueOnly"); if (billOverdueOnly) billOverdueOnly.addEventListener("change", render);

      const exportPDF = $id("exportPDF"); if (exportPDF) exportPDF.addEventListener("click", () => window.print());
      const syncNow = $id("syncNow"); if (syncNow) syncNow.addEventListener("click", async () => {
        try {
          const u1 = localStorage.getItem("txUrl") || $id("txUrl")?.value || "";
          const u2 = localStorage.getItem("billUrl") || $id("billUrl")?.value || "";
          if (u1) {
            const res = await fetch(u1, { cache: 'no-store' });
            const txt = await res.text();
            tx = parseCSV(txt).map(normalizeRowKeys);
          }
          if (u2) {
            const res2 = await fetch(u2, { cache: 'no-store' });
            const txt2 = await res2.text();
            bills = parseCSV(txt2);
          }
          inferAccounts();
          render();
          const last = $id("lastSync");
          if (last) last.textContent = "Синхронизация: " + new Date().toLocaleString();
        } catch(e) {
          const last = $id("lastSync");
          if (last) last.textContent = "Ошибка: " + (e && e.message ? e.message : String(e));
        }
      });

      const txFile = $id("txFile");
      if (txFile) {
        txFile.addEventListener("change", async e => {
          const f = e.target.files[0];
          if (!f) return;
          tx = parseCSV(await f.text()).map(normalizeRowKeys);
          inferAccounts();
          render();
        });
      }
      const billFile = $id("billFile");
      if (billFile) {
        billFile.addEventListener("change", async e => {
          const f = e.target.files[0];
          if (!f) return;
          bills = parseCSV(await f.text());
          render();
        });
      }
      const saveTxUrl = $id("saveTxUrl");
      if (saveTxUrl) saveTxUrl.addEventListener("click", () => {
        const v = $id("txUrl") ? $id("txUrl").value.trim() : "";
        localStorage.setItem("txUrl", v);
        alert("Сохранено URL wyciąga");
      });
      const saveBillUrl = $id("saveBillUrl");
      if (saveBillUrl) saveBillUrl.addEventListener("click", () => {
        const v = $id("billUrl") ? $id("billUrl").value.trim() : "";
        localStorage.setItem("billUrl", v);
        alert("Сохранено URL faktur");
      });

      // cash quick controls (only if present)
      const addIn = $id("addIn"); if (addIn) addIn.addEventListener("click", () =>
        addKasa("przyjęcie", asNum($id("quickAmt")?.value || 0), $id("quickNote")?.value, "ручной")
      );
      const addOut = $id("addOut"); if (addOut) addOut.addEventListener("click", () =>
        addKasa("wydanie", asNum($id("quickAmt")?.value || 0), $id("quickNote")?.value, "ручной")
      );
      const cashClose = $id("cashClose"); if (cashClose) cashClose.addEventListener("click", () => {
        const a = prompt("Итог в кассе (PLN):", kasaBalance().toFixed(2));
        if (a === null) return;
        addKasa("zamknięcie", asNum(a), "close", "ручной");
      });
      const q50 = $id("q50"); if (q50) q50.addEventListener("click", () => {
        const el = $id("quickAmt"); if (!el) return;
        el.value = (Number(el.value || 0) + 50).toFixed(2);
      });
      const q100 = $id("q100"); if (q100) q100.addEventListener("click", () => {
        const el = $id("quickAmt"); if (!el) return;
        el.value = (Number(el.value || 0) + 100).toFixed(2);
      });
      const q200 = $id("q200"); if (q200) q200.addEventListener("click", () => {
        const el = $id("quickAmt"); if (!el) return;
        el.value = (Number(el.value || 0) + 200).toFixed(2);
      });

      // speech stuff: only initialise if elements present and browser supports
      const micBtn = $id("micBtn");
      if (micBtn && (window.SpeechRecognition || window.webkitSpeechRecognition)) {
        const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
        const rec = new SR();
        rec.continuous = false;
        rec.interimResults = false;
        rec.maxAlternatives = 1;
        rec.lang = localStorage.getItem("speechLang") || "pl-PL";
        rec.onstart = () => { micBtn.classList.add('on'); $id("micStatus") && ($id("micStatus").textContent = `🎙️ Слушаю... (${rec.lang})`); };
        rec.onend = () => { micBtn.classList.remove('on'); };
        rec.onresult = (e) => {
          const text = (e.results[0][0].transcript || "").toLowerCase();
          $id("micStatus") && ($id("micStatus").textContent = "🎙️ Распознано: " + text);
          const numMatch = text.match(/(\d+[.,]?\d*)\s*(zł|pln)?/);
          const num = numMatch ? numMatch[1] : null;
          const isOut = /(wyda|minus|wydat|выда|минус|расход)/.test(text);
          const note = text.replace(/(\d+[.,]?\d*\s*(zł|pln)?)/, "").trim();
          if (!num) { $id("micStatus") && ($id("micStatus").textContent = "🎙️ Сумму не нашёл"); return; }
          addKasa(isOut ? "wydanie" : "przyjęcie", asNum(num), note || "голос", "voice");
        };
        micBtn.addEventListener("click", () => {
          try {
            const sel = $id("speechLang");
            if (sel) { rec.lang = sel.value; localStorage.setItem("speechLang", rec.lang); }
            rec.start();
          } catch(e) { $id("micStatus") && ($id("micStatus").textContent = "🎙️ Не смог запустить: " + e.message); }
        });
      }

      // OCR for receipt (if input exists)
      const cashPhoto = $id("cashPhoto");
      if (cashPhoto) cashPhoto.addEventListener("change", async e => {
        const f = e.target.files[0];
        if (!f) return;
        await processImageFileFor('tx', f);
      });

      // settings handlers (safe)
      const applySettings = $id("applySettings");
      if (applySettings) applySettings.addEventListener("click", () => {
        localStorage.setItem("cashPLN", $id("cashPLN") ? $id("cashPLN").value : "0");
        localStorage.setItem("penaltyPct", $id("penaltyPct") ? $id("penaltyPct").value : "0.05");
        localStorage.setItem("intervalMin", $id("intervalMin") ? $id("intervalMin").value : "10");
        localStorage.setItem("rateEUR", $id("rateEUR") ? $id("rateEUR").value : "4.30");
        localStorage.setItem("rateUSD", $id("rateUSD") ? $id("rateUSD").value : "3.95");
        localStorage.setItem("blacklist", $id("blacklist") ? $id("blacklist").value : "");
        localStorage.setItem("autoCash", $id("autoCash") && $id("autoCash").checked ? "1" : "0");
        const modeText = (localStorage.getItem("otd_lang") || "ru") === "ru"
          ? "Режим: " + (($id("autoCash") && $id("autoCash").checked) ? "авто" : "ручной")
          : "Mode: " + (($id("autoCash") && $id("autoCash").checked) ? "auto" : "manual");
        if ($id("modeCash")) $id("modeCash").textContent = modeText;
        render();
      });

      const exportCfg = $id("exportCfg");
      if (exportCfg) exportCfg.addEventListener("click", () => {
        const cfg = {
          txUrl: localStorage.getItem("txUrl") || "",
          billUrl: localStorage.getItem("billUrl") || "",
          cashPLN: localStorage.getItem("cashPLN") || "0",
          penaltyPct: localStorage.getItem("penaltyPct") || "0.05",
          intervalMin: localStorage.getItem("intervalMin") || "10",
          rateEUR: localStorage.getItem("rateEUR") || "4.30",
          rateUSD: localStorage.getItem("rateUSD") || "3.95",
          blacklist: localStorage.getItem("blacklist") || "",
          autoCash: localStorage.getItem("autoCash") || "0",
          accMeta: localStorage.getItem("accMeta") || "{}"
        };
        const blob = new Blob([JSON.stringify(cfg, null, 2)], { type: "application/json" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "onetapday_settings.json";
        a.click();
      });

      const importCfg = $id("importCfg");
      if (importCfg) importCfg.addEventListener("change", async e => {
        const f = e.target.files[0];
        if (!f) return;
        const cfg = JSON.parse(await f.text());
        Object.entries(cfg).forEach(([k, v]) => localStorage.setItem(k, typeof v === "string" ? v : JSON.stringify(v)));
        location.reload();
      });

      // pilot UI (defensive)
      (function pilotUI() {
        function getPilot() { try { return JSON.parse(localStorage.getItem("otd_pilot") || "{}"); } catch(e){ return {}; } }
        function setPilot(s) { try { localStorage.setItem("otd_pilot", JSON.stringify(s)); } catch(e){} }
        function isoDate(d) { const x = new Date(d); return isNaN(x) ? "—" : x.toISOString().slice(0,10); }
        function daysLeft(endIso) { if (!endIso) return 0; const e = new Date(endIso), n = new Date(); return Math.max(0, Math.ceil((e - n) / 86400000)); }
        function updatePilotUI() {
          const s = getPilot();
          const st = s.status || "none";
          let desc = "—";
          if (st === "none") desc = "ожидается оплата депозита";
          if (st === "deposit_paid") desc = "депозит оплачен";
          if (st === "active") desc = "пилот активен";
          if (st === "ended") desc = "пилот завершён";
          if (st === "discount_active") desc = "скидка активна";
          const mini = $id("pilotMini"); if (mini) mini.textContent = "Статус: " + desc;
          const ps = $id("pilotStart"); if (ps) ps.textContent = s.startAt ? isoDate(s.startAt) : "—";
          const pe = $id("pilotEnd"); if (pe) pe.textContent = s.endAt ? isoDate(s.endAt) : "—";
          const pc = $id("pilotCountdown"); if (pc) pc.textContent = (st === "active" && s.endAt) ? (" · осталось " + daysLeft(s.endAt) + " дн.") : "";
          const du = $id("discountUntil"); if (du) du.textContent = s.discountUntil ? isoDate(s.discountUntil) : "—";
          const userEmail = localStorage.getItem("otd_user") || "";
          const isAdmin = userEmail && (userEmail === "1tapday@gmail.com");
          const btnMark = $id("btnMarkPaid"), btnStart = $id("btnStartPilot"), btnReset = $id("btnResetPilot"), btnAct = $id("btnActivateDiscount");
          if (btnMark) btnMark.style.display = isAdmin ? "inline-block" : "none";
          if (btnStart) btnStart.style.display = isAdmin ? "inline-block" : "none";
          if (btnReset) btnReset.style.display = isAdmin ? "inline-block" : "none";
          if (btnAct) btnAct.style.display = (st === "ended" && isAdmin) ? "inline-block" : "none";
        }
        document.addEventListener("click", (e) => {
          const id = e.target && e.target.id;
          if (!id) return;
          let s = getPilot();
          if (id === "btnMarkPaid") {
            // best-effort: call endpoint, fallback to local update
            fetch("/mark-paid", { method: "POST" })
              .then(res => res.json()).then(data => {
                s.status = "deposit_paid"; s.paidAt = new Date().toISOString(); setPilot(s); updatePilotUI();
              }).catch(()=>{ s.status = "deposit_paid"; s.paidAt = new Date().toISOString(); setPilot(s); updatePilotUI(); });
          }
          if (id === "btnStartPilot") {
            fetch("/start-pilot", { method: "POST" })
              .then(res => res.json()).then(data => {
                s.status = "active"; s.startAt = new Date().toISOString(); const d = new Date(); d.setMonth(d.getMonth() + 2); s.endAt = d.toISOString(); setPilot(s); updatePilotUI();
              }).catch(()=>{ s.status = "active"; s.startAt = new Date().toISOString(); const d = new Date(); d.setMonth(d.getMonth() + 2); s.endAt = d.toISOString(); setPilot(s); updatePilotUI(); });
          }
          if (id === "btnActivateDiscount") {
            fetch("/activate-discount", { method: "POST" })
              .then(res => res.json()).then(data => {
                s.status = "discount_active"; s.discountSince = new Date().toISOString(); const e2 = new Date(); e2.setMonth(e2.getMonth() + 12); s.discountUntil = e2.toISOString(); setPilot(s); updatePilotUI();
              }).catch(()=>{ s.status = "discount_active"; s.discountSince = new Date().toISOString(); const e2 = new Date(); e2.setMonth(e2.getMonth() + 12); s.discountUntil = e2.toISOString(); setPilot(s); updatePilotUI(); });
          }
          if (id === "btnResetPilot") {
            localStorage.removeItem("otd_pilot");
            updatePilotUI();
          }
        }, false);
        setInterval(() => {
          const s = JSON.parse(localStorage.getItem("otd_pilot") || "{}");
          if ((s.status || "") === "active") updatePilotUI();
        }, 60000);
        updatePilotUI();
      })();

      // init load
      (function init() {
        loadKasa();
        try { accMeta = JSON.parse(localStorage.getItem("accMeta") || "{}"); } catch(e) { accMeta = {}; }
        try { tx = JSON.parse(localStorage.getItem("tx_manual_import") || "[]").concat(tx); } catch(e){}
        try { bills = JSON.parse(localStorage.getItem("bills_manual_import") || "[]").concat(bills); } catch(e){}
        renderKasa();
        if ($id("txUrl")) $id("txUrl").value = localStorage.getItem("txUrl") || "";
        if ($id("billUrl")) $id("billUrl").value = localStorage.getItem("billUrl") || "";
        if ($id("cashPLN")) $id("cashPLN").value = localStorage.getItem("cashPLN") || "5000";
        if ($id("penaltyPct")) $id("penaltyPct").value = localStorage.getItem("penaltyPct") || "0.05";
        if ($id("intervalMin")) $id("intervalMin").value = localStorage.getItem("intervalMin") || "10";
        if ($id("rateEUR")) $id("rateEUR").value = localStorage.getItem("rateEUR") || "4.30";
        if ($id("rateUSD")) $id("rateUSD").value = localStorage.getItem("rateUSD") || "3.95";
        if ($id("blacklist")) $id("blacklist").value = localStorage.getItem("blacklist") || "";
        if ($id("autoCash")) $id("autoCash").checked = localStorage.getItem("autoCash") === "1";
        const saved = localStorage.getItem("speechLang");
        if (saved && $id("speechLang")) $id("speechLang").value = saved;
        if ($id("modeCash")) $id("modeCash").textContent = (localStorage.getItem("otd_lang") || "ru") === "ru"
          ? "Режим: " + (($id("autoCash") && $id("autoCash").checked) ? "авто" : "ручной")
          : "Mode: " + (($id("autoCash") && $id("autoCash").checked) ? "auto" : "manual");
        inferAccounts();
        render();
      })();
    });
  })();
  </script>

  <!-- defensive patch kept (no changes required) -->
  <script>
  (function(){
    const $ = sel => document.querySelector(sel);
    const $$ = sel => Array.from(document.querySelectorAll(sel));
    function safeCall(name, ...args){ try{ if (typeof window[name] === 'function') return window[name](...args); return null;}catch(e){return null;} }
    function initTabs(){ const tabs = $$('.tabs .tab'); if (!tabs.length) return; tabs.forEach(t => { t.removeEventListener('click', t._otd_cb); const cb = () => { $$(' .tabs .tab').forEach(x=>x.classList.remove('active')); $$('.section').forEach(s=>s.classList.remove('active')); t.classList.add('active'); const sec = t.dataset.sec || t.getAttribute('data-sec') || t.getAttribute('data-section') || t.getAttribute('data-tab'); if (sec) { const el = document.getElementById(sec); if (el) el.classList.add('active'); } if (typeof render === 'function') try { render(); } catch(e){} safeCall('renderPlan'); safeCall('renderForecast'); safeCall('renderKasa'); safeCall('renderAccounts'); }; t._otd_cb = cb; t.addEventListener('click', cb); }); }
    function unblackSections(){ $$('.section').forEach(sec=>{ try{ sec.style.display = ''; if (sec.children.length > 0) sec.classList.add('active'); } catch(e){} }); }
    function initLangButtons(){ const langButtons = $$('.lang button, .lang .btn'); if (!langButtons.length) return; langButtons.forEach(b=>{ b.removeEventListener('click', b._otd_cb); const cb = () => { const L = b.dataset.lang || b.getAttribute('data-lang') || b.textContent.trim().slice(0,2).toLowerCase(); if (typeof applyLang === 'function') { try { applyLang(L); } catch(e){} } else if (window.M && window.M[L]) { document.querySelectorAll('[data-i]').forEach(el=>{ const k = el.getAttribute('data-i'); if (window.M[L][k]) el.textContent = window.M[L][k]; }); } langButtons.forEach(x => x.classList.remove('on')); b.classList.add('on'); localStorage.setItem('otd_lang', L); safeCall('render'); }; b._otd_cb = cb; b.addEventListener('click', cb); }); const saved = localStorage.getItem('otd_lang') || 'ru'; const btn = langButtons.find(b=> (b.dataset.lang||'').toLowerCase()===saved); if (btn) btn._otd_cb(); }
    function ensureForecasts(){ if (typeof renderForecast === 'function') { try { renderForecast(); } catch(e){} return; } const allTx = (window.tx && window.tx.slice()) || (() => { try { return JSON.parse(localStorage.getItem('tx_manual_import')||'[]'); } catch(e){ return []; } })(); const now = new Date(); const sumDays = (days) => { const cutoff = new Date(now.getTime() + days*86400000); return allTx.reduce((s, r) => { const date = (r['Data księgowania'] || r['Дата'] || r['date'] || r['Date']); const d = new Date(toISO(date)); if (isNaN(d)) return s; if (d <= cutoff) return s + Math.abs(Number(r['Kwота']||r['Kwота']||r['amount']||0)); return s; }, 0); }; const s7 = sumDays(7), s30 = sumDays(30); if ( $('#forecastBars') ) { $('#forecastBars').innerHTML = '<div class="muted">7d forecast (sum amounts): ' + s7.toFixed(2) + ' PLN</div>'; } if ( $('#forecast30Table') ) { $('#forecast30Table').innerHTML = '<div class="muted">30d forecast (sum amounts): ' + s30.toFixed(2) + ' PLN</div>'; } }
    function initStripeButtons(){ const btnIds = ['pay99','payNow','payAfterDemo','payNowBtn','payNowBtn2']; const btns = btnIds.map(id=>document.getElementById(id)).filter(Boolean); const more = Array.from(new Set([].concat(Array.from(document.querySelectorAll('button.pay-btn, button.btn.pay, button.pay, .pay-btn'))))); const unique = Array.from(new Set([].concat(btns, more))); if (!unique.length) return; unique.forEach(b=>{ b.removeEventListener('click', b._otd_cb); const cb = async (e) => { e.preventDefault(); const fallbackLink = localStorage.getItem('stripe_link') || localStorage.getItem('stripePaymentLink'); if (fallbackLink) { window.location.href = fallbackLink; return; } try { const resp = await fetch('/create-checkout-session', { method: 'POST', headers: {'Content-Type':'application/json'}, credentials: 'include', body: JSON.stringify({demo: true}) }); if (!resp.ok) { const txt = await resp.text().catch(()=>null); alert('Ошибка создания сессии: ' + (txt || resp.status)); return; } const json = await resp.json().catch(()=>null); if (json && json.url) { window.location.href = json.url; return; } if (json && json.session && json.session.url) { window.location.href = json.session.url; return; } alert('Сервер вернул неизвестный ответ. Проверь логи сервера.'); } catch(err){ alert('Не удалось связаться с сервером /create-checkout-session. Можно временно положить ссылку в localStorage.stripe_link'); } }; b._otd_cb = cb; b.addEventListener('click', cb); }); }
    function ensureRenderers(){ if (typeof renderInvoices === 'function') try { renderInvoices(); } catch(e) {} if (typeof render === 'function') try { render(); } catch(e) {} if (typeof renderAccounts === 'function') try { renderAccounts(); } catch(e) {} if (typeof renderKasa === 'function') try { renderKasa(); } catch(e) {} }
    function initAll(){ try { initTabs(); } catch(e){} try { unblackSections(); } catch(e){} try { initLangButtons(); } catch(e){} try { ensureForecasts(); } catch(e){} try { initStripeButtons(); } catch(e){} try { ensureRenderers(); } catch(e){} safeCall('render'); safeCall('renderPlan'); safeCall('renderKasa'); safeCall('renderAccounts'); safeCall('renderForecast'); }
    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', initAll); else initAll();
    window.OTD_PATCH = { init: initAll, report: function(){ return { sections: Array.from(document.querySelectorAll('.section')).map(s => ({id:s.id, classes: s.className, children: s.children.length })), langButtons: Array.from(document.querySelectorAll('.lang button')).map(b=>({text:b.textContent, data: b.dataset})), stripeButtons: Array.from(new Set(['pay99','payNow','payAfterDemo','payNowBtn','payNowBtn2'].map(id=>document.getElementById(id)).filter(Boolean))).length }; } };
  })();
  </script>
</body>
</html>

